import {MarkersService as Ae} from "./markers.knhZWxmI.js";
import {a as Oe, b as ze} from "./Cookie.astro_astro_type_script_index_0_lang.WHDXDktG.js";
import "./Action.astro_astro_type_script_index_0_lang.C4sRQqxd.js";
import {c as De, g as ke} from "./_commonjsHelpers.Cpj98o6Y.js";
import {b as xe} from "./bootstrap.BHn072p8.js";
import "./hoisted.CY0CLRUD.js";
import "./GoogleButton.astro_astro_type_script_index_0_lang.DXufnMWW.js";
import "./base.Dp3-MWEb.js";
import "./redirect.wOMpoOAS.js";
Ae.init();
Oe();
function pe(i) {
	return i !== null && typeof i == "object" && "constructor"in i && i.constructor === Object
}
function fe(i, e) {
	i === void 0 && (i = {}),
	e === void 0 && (e = {}),
	Object.keys(e).forEach(t=>{
		typeof i[t] > "u" ? i[t] = e[t] : pe(e[t]) && pe(i[t]) && Object.keys(e[t]).length > 0 && fe(i[t], e[t])
	}
	)
}
const Ee = {
	body: {},
	addEventListener() {},
	removeEventListener() {},
	activeElement: {
		blur() {},
		nodeName: ""
	},
	querySelector() {
		return null
	},
	querySelectorAll() {
		return []
	},
	getElementById() {
		return null
	},
	createEvent() {
		return {
			initEvent() {}
		}
	},
	createElement() {
		return {
			children: [],
			childNodes: [],
			style: {},
			setAttribute() {},
			getElementsByTagName() {
				return []
			}
		}
	},
	createElementNS() {
		return {}
	},
	importNode() {
		return null
	},
	location: {
		hash: "",
		host: "",
		hostname: "",
		href: "",
		origin: "",
		pathname: "",
		protocol: "",
		search: ""
	}
};
function _() {
	const i = typeof document < "u" ? document : {};
	return fe(i, Ee),
	i
}
const Ge = {
	document: Ee,
	navigator: {
		userAgent: ""
	},
	location: {
		hash: "",
		host: "",
		hostname: "",
		href: "",
		origin: "",
		pathname: "",
		protocol: "",
		search: ""
	},
	history: {
		replaceState() {},
		pushState() {},
		go() {},
		back() {}
	},
	CustomEvent: function() {
		return this
	},
	addEventListener() {},
	removeEventListener() {},
	getComputedStyle() {
		return {
			getPropertyValue() {
				return ""
			}
		}
	},
	Image() {},
	Date() {},
	screen: {},
	setTimeout() {},
	clearTimeout() {},
	matchMedia() {
		return {}
	},
	requestAnimationFrame(i) {
		return typeof setTimeout > "u" ? (i(),
		null) : setTimeout(i, 0)
	},
	cancelAnimationFrame(i) {
		typeof setTimeout > "u" || clearTimeout(i)
	}
};
function $() {
	const i = typeof window < "u" ? window : {};
	return fe(i, Ge),
	i
}
function $e(i) {
	return i === void 0 && (i = ""),
	i.trim().split(" ").filter(e=>!!e.trim())
}
function Ve(i) {
	const e = i;
	Object.keys(e).forEach(t=>{
		try {
			e[t] = null
		} catch {}
		try {
			delete e[t]
		} catch {}
	}
	)
}
function le(i, e) {
	return e === void 0 && (e = 0),
	setTimeout(i, e)
}
function U() {
	return Date.now()
}
function Be(i) {
	const e = $();
	let t;
	return e.getComputedStyle && (t = e.getComputedStyle(i, null)),
	!t && i.currentStyle && (t = i.currentStyle),
	t || (t = i.style),
	t
}
function Fe(i, e) {
	e === void 0 && (e = "x");
	const t = $();
	let s, n, r;
	const o = Be(i);
	return t.WebKitCSSMatrix ? (n = o.transform || o.webkitTransform,
	n.split(",").length > 6 && (n = n.split(", ").map(l=>l.replace(",", ".")).join(", ")),
	r = new t.WebKitCSSMatrix(n === "none" ? "" : n)) : (r = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
	s = r.toString().split(",")),
	e === "x" && (t.WebKitCSSMatrix ? n = r.m41 : s.length === 16 ? n = parseFloat(s[12]) : n = parseFloat(s[4])),
	e === "y" && (t.WebKitCSSMatrix ? n = r.m42 : s.length === 16 ? n = parseFloat(s[13]) : n = parseFloat(s[5])),
	n || 0
}
function j(i) {
	return typeof i == "object" && i !== null && i.constructor && Object.prototype.toString.call(i).slice(8, -1) === "Object"
}
function _e(i) {
	return typeof window < "u" && typeof window.HTMLElement < "u" ? i instanceof HTMLElement : i && (i.nodeType === 1 || i.nodeType === 11)
}
function G() {
	const i = Object(arguments.length <= 0 ? void 0 : arguments[0])
	  , e = ["__proto__", "constructor", "prototype"];
	for (let t = 1; t < arguments.length; t += 1) {
		const s = t < 0 || arguments.length <= t ? void 0 : arguments[t];
		if (s != null && !_e(s)) {
			const n = Object.keys(Object(s)).filter(r=>e.indexOf(r) < 0);
			for (let r = 0, o = n.length; r < o; r += 1) {
				const l = n[r]
				  , a = Object.getOwnPropertyDescriptor(s, l);
				a !== void 0 && a.enumerable && (j(i[l]) && j(s[l]) ? s[l].__swiper__ ? i[l] = s[l] : G(i[l], s[l]) : !j(i[l]) && j(s[l]) ? (i[l] = {},
				s[l].__swiper__ ? i[l] = s[l] : G(i[l], s[l])) : i[l] = s[l])
			}
		}
	}
	return i
}
function q(i, e, t) {
	i.style.setProperty(e, t)
}
function Ce(i) {
	let {swiper: e, targetPosition: t, side: s} = i;
	const n = $()
	  , r = -e.translate;
	let o = null, l;
	const a = e.params.speed;
	e.wrapperEl.style.scrollSnapType = "none",
	n.cancelAnimationFrame(e.cssModeFrameID);
	const d = t > r ? "next" : "prev"
	  , c = (h,m)=>d === "next" && h >= m || d === "prev" && h <= m
	  , p = ()=>{
		l = new Date().getTime(),
		o === null && (o = l);
		const h = Math.max(Math.min((l - o) / a, 1), 0)
		  , m = .5 - Math.cos(h * Math.PI) / 2;
		let v = r + m * (t - r);
		if (c(v, t) && (v = t),
		e.wrapperEl.scrollTo({
			[s]: v
		}),
		c(v, t)) {
			e.wrapperEl.style.overflow = "hidden",
			e.wrapperEl.style.scrollSnapType = "",
			setTimeout(()=>{
				e.wrapperEl.style.overflow = "",
				e.wrapperEl.scrollTo({
					[s]: v
				})
			}
			),
			n.cancelAnimationFrame(e.cssModeFrameID);
			return
		}
		e.cssModeFrameID = n.requestAnimationFrame(p)
	}
	;
	p()
}
function F(i, e) {
	return e === void 0 && (e = ""),
	[...i.children].filter(t=>t.matches(e))
}
function J(i) {
	try {
		console.warn(i);
		return
	} catch {}
}
function Q(i, e) {
	e === void 0 && (e = []);
	const t = document.createElement(i);
	return t.classList.add(...Array.isArray(e) ? e : $e(e)),
	t
}
function Ne(i, e) {
	const t = [];
	for (; i.previousElementSibling; ) {
		const s = i.previousElementSibling;
		e ? s.matches(e) && t.push(s) : t.push(s),
		i = s
	}
	return t
}
function He(i, e) {
	const t = [];
	for (; i.nextElementSibling; ) {
		const s = i.nextElementSibling;
		e ? s.matches(e) && t.push(s) : t.push(s),
		i = s
	}
	return t
}
function N(i, e) {
	return $().getComputedStyle(i, null).getPropertyValue(e)
}
function Z(i) {
	let e = i, t;
	if (e) {
		for (t = 0; (e = e.previousSibling) !== null; )
			e.nodeType === 1 && (t += 1);
		return t
	}
}
function Me(i, e) {
	const t = [];
	let s = i.parentElement;
	for (; s; )
		e ? s.matches(e) && t.push(s) : t.push(s),
		s = s.parentElement;
	return t
}
function oe(i, e, t) {
	const s = $();
	return t ? i[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(s.getComputedStyle(i, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(s.getComputedStyle(i, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : i.offsetWidth
}
let te;
function Re() {
	const i = $()
	  , e = _();
	return {
		smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior"in e.documentElement.style,
		touch: !!("ontouchstart"in i || i.DocumentTouch && e instanceof i.DocumentTouch)
	}
}
function Pe() {
	return te || (te = Re()),
	te
}
let ie;
function We(i) {
	let {userAgent: e} = i === void 0 ? {} : i;
	const t = Pe()
	  , s = $()
	  , n = s.navigator.platform
	  , r = e || s.navigator.userAgent
	  , o = {
		ios: !1,
		android: !1
	}
	  , l = s.screen.width
	  , a = s.screen.height
	  , d = r.match(/(Android);?[\s\/]+([\d.]+)?/);
	let c = r.match(/(iPad).*OS\s([\d_]+)/);
	const p = r.match(/(iPod)(.*OS\s([\d_]+))?/)
	  , h = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
	  , m = n === "Win32";
	let v = n === "MacIntel";
	const S = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
	return !c && v && t.touch && S.indexOf(`${l}x${a}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/),
	c || (c = [0, 1, "13_0_0"]),
	v = !1),
	d && !m && (o.os = "android",
	o.android = !0),
	(c || h || p) && (o.os = "ios",
	o.ios = !0),
	o
}
function Ye(i) {
	return i === void 0 && (i = {}),
	ie || (ie = We(i)),
	ie
}
let se;
function je() {
	const i = $();
	let e = !1;
	function t() {
		const s = i.navigator.userAgent.toLowerCase();
		return s.indexOf("safari") >= 0 && s.indexOf("chrome") < 0 && s.indexOf("android") < 0
	}
	if (t()) {
		const s = String(i.navigator.userAgent);
		if (s.includes("Version/")) {
			const [n,r] = s.split("Version/")[1].split(" ")[0].split(".").map(o=>Number(o));
			e = n < 16 || n === 16 && r < 2
		}
	}
	return {
		isSafari: e || t(),
		needPerspectiveFix: e,
		isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(i.navigator.userAgent)
	}
}
function qe() {
	return se || (se = je()),
	se
}
function Xe(i) {
	let {swiper: e, on: t, emit: s} = i;
	const n = $();
	let r = null
	  , o = null;
	const l = ()=>{
		!e || e.destroyed || !e.initialized || (s("beforeResize"),
		s("resize"))
	}
	  , a = ()=>{
		!e || e.destroyed || !e.initialized || (r = new ResizeObserver(p=>{
			o = n.requestAnimationFrame(()=>{
				const {width: h, height: m} = e;
				let v = h
				  , S = m;
				p.forEach(E=>{
					let {contentBoxSize: w, contentRect: u, target: f} = E;
					f && f !== e.el || (v = u ? u.width : (w[0] || w).inlineSize,
					S = u ? u.height : (w[0] || w).blockSize)
				}
				),
				(v !== h || S !== m) && l()
			}
			)
		}
		),
		r.observe(e.el))
	}
	  , d = ()=>{
		o && n.cancelAnimationFrame(o),
		r && r.unobserve && e.el && (r.unobserve(e.el),
		r = null)
	}
	  , c = ()=>{
		!e || e.destroyed || !e.initialized || s("orientationchange")
	}
	;
	t("init", ()=>{
		if (e.params.resizeObserver && typeof n.ResizeObserver < "u") {
			a();
			return
		}
		n.addEventListener("resize", l),
		n.addEventListener("orientationchange", c)
	}
	),
	t("destroy", ()=>{
		d(),
		n.removeEventListener("resize", l),
		n.removeEventListener("orientationchange", c)
	}
	)
}
function Ke(i) {
	let {swiper: e, extendParams: t, on: s, emit: n} = i;
	const r = []
	  , o = $()
	  , l = function(c, p) {
		p === void 0 && (p = {});
		const h = o.MutationObserver || o.WebkitMutationObserver
		  , m = new h(v=>{
			if (e.__preventObserver__)
				return;
			if (v.length === 1) {
				n("observerUpdate", v[0]);
				return
			}
			const S = function() {
				n("observerUpdate", v[0])
			};
			o.requestAnimationFrame ? o.requestAnimationFrame(S) : o.setTimeout(S, 0)
		}
		);
		m.observe(c, {
			attributes: typeof p.attributes > "u" ? !0 : p.attributes,
			childList: typeof p.childList > "u" ? !0 : p.childList,
			characterData: typeof p.characterData > "u" ? !0 : p.characterData
		}),
		r.push(m)
	}
	  , a = ()=>{
		if (e.params.observer) {
			if (e.params.observeParents) {
				const c = Me(e.hostEl);
				for (let p = 0; p < c.length; p += 1)
					l(c[p])
			}
			l(e.hostEl, {
				childList: e.params.observeSlideChildren
			}),
			l(e.wrapperEl, {
				attributes: !1
			})
		}
	}
	  , d = ()=>{
		r.forEach(c=>{
			c.disconnect()
		}
		),
		r.splice(0, r.length)
	}
	;
	t({
		observer: !1,
		observeParents: !1,
		observeSlideChildren: !1
	}),
	s("init", a),
	s("destroy", d)
}
var Ue = {
	on(i, e, t) {
		const s = this;
		if (!s.eventsListeners || s.destroyed || typeof e != "function")
			return s;
		const n = t ? "unshift" : "push";
		return i.split(" ").forEach(r=>{
			s.eventsListeners[r] || (s.eventsListeners[r] = []),
			s.eventsListeners[r][n](e)
		}
		),
		s
	},
	once(i, e, t) {
		const s = this;
		if (!s.eventsListeners || s.destroyed || typeof e != "function")
			return s;
		function n() {
			s.off(i, n),
			n.__emitterProxy && delete n.__emitterProxy;
			for (var r = arguments.length, o = new Array(r), l = 0; l < r; l++)
				o[l] = arguments[l];
			e.apply(s, o)
		}
		return n.__emitterProxy = e,
		s.on(i, n, t)
	},
	onAny(i, e) {
		const t = this;
		if (!t.eventsListeners || t.destroyed || typeof i != "function")
			return t;
		const s = e ? "unshift" : "push";
		return t.eventsAnyListeners.indexOf(i) < 0 && t.eventsAnyListeners[s](i),
		t
	},
	offAny(i) {
		const e = this;
		if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners)
			return e;
		const t = e.eventsAnyListeners.indexOf(i);
		return t >= 0 && e.eventsAnyListeners.splice(t, 1),
		e
	},
	off(i, e) {
		const t = this;
		return !t.eventsListeners || t.destroyed || !t.eventsListeners || i.split(" ").forEach(s=>{
			typeof e > "u" ? t.eventsListeners[s] = [] : t.eventsListeners[s] && t.eventsListeners[s].forEach((n,r)=>{
				(n === e || n.__emitterProxy && n.__emitterProxy === e) && t.eventsListeners[s].splice(r, 1)
			}
			)
		}
		),
		t
	},
	emit() {
		const i = this;
		if (!i.eventsListeners || i.destroyed || !i.eventsListeners)
			return i;
		let e, t, s;
		for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
			r[o] = arguments[o];
		return typeof r[0] == "string" || Array.isArray(r[0]) ? (e = r[0],
		t = r.slice(1, r.length),
		s = i) : (e = r[0].events,
		t = r[0].data,
		s = r[0].context || i),
		t.unshift(s),
		(Array.isArray(e) ? e : e.split(" ")).forEach(a=>{
			i.eventsAnyListeners && i.eventsAnyListeners.length && i.eventsAnyListeners.forEach(d=>{
				d.apply(s, [a, ...t])
			}
			),
			i.eventsListeners && i.eventsListeners[a] && i.eventsListeners[a].forEach(d=>{
				d.apply(s, t)
			}
			)
		}
		),
		i
	}
};
function Je() {
	const i = this;
	let e, t;
	const s = i.el;
	typeof i.params.width < "u" && i.params.width !== null ? e = i.params.width : e = s.clientWidth,
	typeof i.params.height < "u" && i.params.height !== null ? t = i.params.height : t = s.clientHeight,
	!(e === 0 && i.isHorizontal() || t === 0 && i.isVertical()) && (e = e - parseInt(N(s, "padding-left") || 0, 10) - parseInt(N(s, "padding-right") || 0, 10),
	t = t - parseInt(N(s, "padding-top") || 0, 10) - parseInt(N(s, "padding-bottom") || 0, 10),
	Number.isNaN(e) && (e = 0),
	Number.isNaN(t) && (t = 0),
	Object.assign(i, {
		width: e,
		height: t,
		size: i.isHorizontal() ? e : t
	}))
}
function Qe() {
	const i = this;
	function e(y, x) {
		return parseFloat(y.getPropertyValue(i.getDirectionLabel(x)) || 0)
	}
	const t = i.params
	  , {wrapperEl: s, slidesEl: n, size: r, rtlTranslate: o, wrongRTL: l} = i
	  , a = i.virtual && t.virtual.enabled
	  , d = a ? i.virtual.slides.length : i.slides.length
	  , c = F(n, `.${i.params.slideClass}, swiper-slide`)
	  , p = a ? i.virtual.slides.length : c.length;
	let h = [];
	const m = []
	  , v = [];
	let S = t.slidesOffsetBefore;
	typeof S == "function" && (S = t.slidesOffsetBefore.call(i));
	let E = t.slidesOffsetAfter;
	typeof E == "function" && (E = t.slidesOffsetAfter.call(i));
	const w = i.snapGrid.length
	  , u = i.slidesGrid.length;
	let f = t.spaceBetween
	  , g = -S
	  , T = 0
	  , C = 0;
	if (typeof r > "u")
		return;
	typeof f == "string" && f.indexOf("%") >= 0 ? f = parseFloat(f.replace("%", "")) / 100 * r : typeof f == "string" && (f = parseFloat(f)),
	i.virtualSize = -f,
	c.forEach(y=>{
		o ? y.style.marginLeft = "" : y.style.marginRight = "",
		y.style.marginBottom = "",
		y.style.marginTop = ""
	}
	),
	t.centeredSlides && t.cssMode && (q(s, "--swiper-centered-offset-before", ""),
	q(s, "--swiper-centered-offset-after", ""));
	const z = t.grid && t.grid.rows > 1 && i.grid;
	z ? i.grid.initSlides(c) : i.grid && i.grid.unsetSlides();
	let A;
	const L = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter(y=>typeof t.breakpoints[y].slidesPerView < "u").length > 0;
	for (let y = 0; y < p; y += 1) {
		A = 0;
		let x;
		if (c[y] && (x = c[y]),
		z && i.grid.updateSlide(y, x, c),
		!(c[y] && N(x, "display") === "none")) {
			if (t.slidesPerView === "auto") {
				L && (c[y].style[i.getDirectionLabel("width")] = "");
				const M = getComputedStyle(x)
				  , b = x.style.transform
				  , P = x.style.webkitTransform;
				if (b && (x.style.transform = "none"),
				P && (x.style.webkitTransform = "none"),
				t.roundLengths)
					A = i.isHorizontal() ? oe(x, "width", !0) : oe(x, "height", !0);
				else {
					const I = e(M, "width")
					  , D = e(M, "padding-left")
					  , ee = e(M, "padding-right")
					  , O = e(M, "margin-left")
					  , V = e(M, "margin-right")
					  , k = M.getPropertyValue("box-sizing");
					if (k && k === "border-box")
						A = I + O + V;
					else {
						const {clientWidth: H, offsetWidth: Y} = x;
						A = I + D + ee + O + V + (Y - H)
					}
				}
				b && (x.style.transform = b),
				P && (x.style.webkitTransform = P),
				t.roundLengths && (A = Math.floor(A))
			} else
				A = (r - (t.slidesPerView - 1) * f) / t.slidesPerView,
				t.roundLengths && (A = Math.floor(A)),
				c[y] && (c[y].style[i.getDirectionLabel("width")] = `${A}px`);
			c[y] && (c[y].swiperSlideSize = A),
			v.push(A),
			t.centeredSlides ? (g = g + A / 2 + T / 2 + f,
			T === 0 && y !== 0 && (g = g - r / 2 - f),
			y === 0 && (g = g - r / 2 - f),
			Math.abs(g) < 1 / 1e3 && (g = 0),
			t.roundLengths && (g = Math.floor(g)),
			C % t.slidesPerGroup === 0 && h.push(g),
			m.push(g)) : (t.roundLengths && (g = Math.floor(g)),
			(C - Math.min(i.params.slidesPerGroupSkip, C)) % i.params.slidesPerGroup === 0 && h.push(g),
			m.push(g),
			g = g + A + f),
			i.virtualSize += A + f,
			T = A,
			C += 1
		}
	}
	if (i.virtualSize = Math.max(i.virtualSize, r) + E,
	o && l && (t.effect === "slide" || t.effect === "coverflow") && (s.style.width = `${i.virtualSize + f}px`),
	t.setWrapperSize && (s.style[i.getDirectionLabel("width")] = `${i.virtualSize + f}px`),
	z && i.grid.updateWrapperSize(A, h),
	!t.centeredSlides) {
		const y = [];
		for (let x = 0; x < h.length; x += 1) {
			let M = h[x];
			t.roundLengths && (M = Math.floor(M)),
			h[x] <= i.virtualSize - r && y.push(M)
		}
		h = y,
		Math.floor(i.virtualSize - r) - Math.floor(h[h.length - 1]) > 1 && h.push(i.virtualSize - r)
	}
	if (a && t.loop) {
		const y = v[0] + f;
		if (t.slidesPerGroup > 1) {
			const x = Math.ceil((i.virtual.slidesBefore + i.virtual.slidesAfter) / t.slidesPerGroup)
			  , M = y * t.slidesPerGroup;
			for (let b = 0; b < x; b += 1)
				h.push(h[h.length - 1] + M)
		}
		for (let x = 0; x < i.virtual.slidesBefore + i.virtual.slidesAfter; x += 1)
			t.slidesPerGroup === 1 && h.push(h[h.length - 1] + y),
			m.push(m[m.length - 1] + y),
			i.virtualSize += y
	}
	if (h.length === 0 && (h = [0]),
	f !== 0) {
		const y = i.isHorizontal() && o ? "marginLeft" : i.getDirectionLabel("marginRight");
		c.filter((x,M)=>!t.cssMode || t.loop ? !0 : M !== c.length - 1).forEach(x=>{
			x.style[y] = `${f}px`
		}
		)
	}
	if (t.centeredSlides && t.centeredSlidesBounds) {
		let y = 0;
		v.forEach(M=>{
			y += M + (f || 0)
		}
		),
		y -= f;
		const x = y - r;
		h = h.map(M=>M <= 0 ? -S : M > x ? x + E : M)
	}
	if (t.centerInsufficientSlides) {
		let y = 0;
		if (v.forEach(x=>{
			y += x + (f || 0)
		}
		),
		y -= f,
		y < r) {
			const x = (r - y) / 2;
			h.forEach((M,b)=>{
				h[b] = M - x
			}
			),
			m.forEach((M,b)=>{
				m[b] = M + x
			}
			)
		}
	}
	if (Object.assign(i, {
		slides: c,
		snapGrid: h,
		slidesGrid: m,
		slidesSizesGrid: v
	}),
	t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
		q(s, "--swiper-centered-offset-before", `${-h[0]}px`),
		q(s, "--swiper-centered-offset-after", `${i.size / 2 - v[v.length - 1] / 2}px`);
		const y = -i.snapGrid[0]
		  , x = -i.slidesGrid[0];
		i.snapGrid = i.snapGrid.map(M=>M + y),
		i.slidesGrid = i.slidesGrid.map(M=>M + x)
	}
	if (p !== d && i.emit("slidesLengthChange"),
	h.length !== w && (i.params.watchOverflow && i.checkOverflow(),
	i.emit("snapGridLengthChange")),
	m.length !== u && i.emit("slidesGridLengthChange"),
	t.watchSlidesProgress && i.updateSlidesOffset(),
	i.emit("slidesUpdated"),
	!a && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
		const y = `${t.containerModifierClass}backface-hidden`
		  , x = i.el.classList.contains(y);
		p <= t.maxBackfaceHiddenSlides ? x || i.el.classList.add(y) : x && i.el.classList.remove(y)
	}
}
function Ze(i) {
	const e = this
	  , t = []
	  , s = e.virtual && e.params.virtual.enabled;
	let n = 0, r;
	typeof i == "number" ? e.setTransition(i) : i === !0 && e.setTransition(e.params.speed);
	const o = l=>s ? e.slides[e.getSlideIndexByData(l)] : e.slides[l];
	if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
		if (e.params.centeredSlides)
			(e.visibleSlides || []).forEach(l=>{
				t.push(l)
			}
			);
		else
			for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
				const l = e.activeIndex + r;
				if (l > e.slides.length && !s)
					break;
				t.push(o(l))
			}
	else
		t.push(o(e.activeIndex));
	for (r = 0; r < t.length; r += 1)
		if (typeof t[r] < "u") {
			const l = t[r].offsetHeight;
			n = l > n ? l : n
		}
	(n || n === 0) && (e.wrapperEl.style.height = `${n}px`)
}
function et() {
	const i = this
	  , e = i.slides
	  , t = i.isElement ? i.isHorizontal() ? i.wrapperEl.offsetLeft : i.wrapperEl.offsetTop : 0;
	for (let s = 0; s < e.length; s += 1)
		e[s].swiperSlideOffset = (i.isHorizontal() ? e[s].offsetLeft : e[s].offsetTop) - t - i.cssOverflowAdjustment()
}
function tt(i) {
	i === void 0 && (i = this && this.translate || 0);
	const e = this
	  , t = e.params
	  , {slides: s, rtlTranslate: n, snapGrid: r} = e;
	if (s.length === 0)
		return;
	typeof s[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
	let o = -i;
	n && (o = i),
	s.forEach(a=>{
		a.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass)
	}
	),
	e.visibleSlidesIndexes = [],
	e.visibleSlides = [];
	let l = t.spaceBetween;
	typeof l == "string" && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * e.size : typeof l == "string" && (l = parseFloat(l));
	for (let a = 0; a < s.length; a += 1) {
		const d = s[a];
		let c = d.swiperSlideOffset;
		t.cssMode && t.centeredSlides && (c -= s[0].swiperSlideOffset);
		const p = (o + (t.centeredSlides ? e.minTranslate() : 0) - c) / (d.swiperSlideSize + l)
		  , h = (o - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) / (d.swiperSlideSize + l)
		  , m = -(o - c)
		  , v = m + e.slidesSizesGrid[a]
		  , S = m >= 0 && m <= e.size - e.slidesSizesGrid[a];
		(m >= 0 && m < e.size - 1 || v > 1 && v <= e.size || m <= 0 && v >= e.size) && (e.visibleSlides.push(d),
		e.visibleSlidesIndexes.push(a),
		s[a].classList.add(t.slideVisibleClass)),
		S && s[a].classList.add(t.slideFullyVisibleClass),
		d.progress = n ? -p : p,
		d.originalProgress = n ? -h : h
	}
}
function it(i) {
	const e = this;
	if (typeof i > "u") {
		const c = e.rtlTranslate ? -1 : 1;
		i = e && e.translate && e.translate * c || 0
	}
	const t = e.params
	  , s = e.maxTranslate() - e.minTranslate();
	let {progress: n, isBeginning: r, isEnd: o, progressLoop: l} = e;
	const a = r
	  , d = o;
	if (s === 0)
		n = 0,
		r = !0,
		o = !0;
	else {
		n = (i - e.minTranslate()) / s;
		const c = Math.abs(i - e.minTranslate()) < 1
		  , p = Math.abs(i - e.maxTranslate()) < 1;
		r = c || n <= 0,
		o = p || n >= 1,
		c && (n = 0),
		p && (n = 1)
	}
	if (t.loop) {
		const c = e.getSlideIndexByData(0)
		  , p = e.getSlideIndexByData(e.slides.length - 1)
		  , h = e.slidesGrid[c]
		  , m = e.slidesGrid[p]
		  , v = e.slidesGrid[e.slidesGrid.length - 1]
		  , S = Math.abs(i);
		S >= h ? l = (S - h) / v : l = (S + v - m) / v,
		l > 1 && (l -= 1)
	}
	Object.assign(e, {
		progress: n,
		progressLoop: l,
		isBeginning: r,
		isEnd: o
	}),
	(t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(i),
	r && !a && e.emit("reachBeginning toEdge"),
	o && !d && e.emit("reachEnd toEdge"),
	(a && !r || d && !o) && e.emit("fromEdge"),
	e.emit("progress", n)
}
function st() {
	const i = this
	  , {slides: e, params: t, slidesEl: s, activeIndex: n} = i
	  , r = i.virtual && t.virtual.enabled
	  , o = i.grid && t.grid && t.grid.rows > 1
	  , l = p=>F(s, `.${t.slideClass}${p}, swiper-slide${p}`)[0];
	e.forEach(p=>{
		p.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass)
	}
	);
	let a, d, c;
	if (r)
		if (t.loop) {
			let p = n - i.virtual.slidesBefore;
			p < 0 && (p = i.virtual.slides.length + p),
			p >= i.virtual.slides.length && (p -= i.virtual.slides.length),
			a = l(`[data-swiper-slide-index="${p}"]`)
		} else
			a = l(`[data-swiper-slide-index="${n}"]`);
	else
		o ? (a = e.filter(p=>p.column === n)[0],
		c = e.filter(p=>p.column === n + 1)[0],
		d = e.filter(p=>p.column === n - 1)[0]) : a = e[n];
	a && (a.classList.add(t.slideActiveClass),
	o ? (c && c.classList.add(t.slideNextClass),
	d && d.classList.add(t.slidePrevClass)) : (c = He(a, `.${t.slideClass}, swiper-slide`)[0],
	t.loop && !c && (c = e[0]),
	c && c.classList.add(t.slideNextClass),
	d = Ne(a, `.${t.slideClass}, swiper-slide`)[0],
	t.loop && !d === 0 && (d = e[e.length - 1]),
	d && d.classList.add(t.slidePrevClass))),
	i.emitSlidesClasses()
}
const K = (i,e)=>{
	if (!i || i.destroyed || !i.params)
		return;
	const t = ()=>i.isElement ? "swiper-slide" : `.${i.params.slideClass}`
	  , s = e.closest(t());
	if (s) {
		let n = s.querySelector(`.${i.params.lazyPreloaderClass}`);
		!n && i.isElement && (s.shadowRoot ? n = s.shadowRoot.querySelector(`.${i.params.lazyPreloaderClass}`) : requestAnimationFrame(()=>{
			s.shadowRoot && (n = s.shadowRoot.querySelector(`.${i.params.lazyPreloaderClass}`),
			n && n.remove())
		}
		)),
		n && n.remove()
	}
}
  , re = (i,e)=>{
	if (!i.slides[e])
		return;
	const t = i.slides[e].querySelector('[loading="lazy"]');
	t && t.removeAttribute("loading")
}
  , de = i=>{
	if (!i || i.destroyed || !i.params)
		return;
	let e = i.params.lazyPreloadPrevNext;
	const t = i.slides.length;
	if (!t || !e || e < 0)
		return;
	e = Math.min(e, t);
	const s = i.params.slidesPerView === "auto" ? i.slidesPerViewDynamic() : Math.ceil(i.params.slidesPerView)
	  , n = i.activeIndex;
	if (i.params.grid && i.params.grid.rows > 1) {
		const o = n
		  , l = [o - e];
		l.push(...Array.from({
			length: e
		}).map((a,d)=>o + s + d)),
		i.slides.forEach((a,d)=>{
			l.includes(a.column) && re(i, d)
		}
		);
		return
	}
	const r = n + s - 1;
	if (i.params.rewind || i.params.loop)
		for (let o = n - e; o <= r + e; o += 1) {
			const l = (o % t + t) % t;
			(l < n || l > r) && re(i, l)
		}
	else
		for (let o = Math.max(n - e, 0); o <= Math.min(r + e, t - 1); o += 1)
			o !== n && (o > r || o < n) && re(i, o)
}
;
function rt(i) {
	const {slidesGrid: e, params: t} = i
	  , s = i.rtlTranslate ? i.translate : -i.translate;
	let n;
	for (let r = 0; r < e.length; r += 1)
		typeof e[r + 1] < "u" ? s >= e[r] && s < e[r + 1] - (e[r + 1] - e[r]) / 2 ? n = r : s >= e[r] && s < e[r + 1] && (n = r + 1) : s >= e[r] && (n = r);
	return t.normalizeSlideIndex && (n < 0 || typeof n > "u") && (n = 0),
	n
}
function nt(i) {
	const e = this
	  , t = e.rtlTranslate ? e.translate : -e.translate
	  , {snapGrid: s, params: n, activeIndex: r, realIndex: o, snapIndex: l} = e;
	let a = i, d;
	const c = m=>{
		let v = m - e.virtual.slidesBefore;
		return v < 0 && (v = e.virtual.slides.length + v),
		v >= e.virtual.slides.length && (v -= e.virtual.slides.length),
		v
	}
	;
	if (typeof a > "u" && (a = rt(e)),
	s.indexOf(t) >= 0)
		d = s.indexOf(t);
	else {
		const m = Math.min(n.slidesPerGroupSkip, a);
		d = m + Math.floor((a - m) / n.slidesPerGroup)
	}
	if (d >= s.length && (d = s.length - 1),
	a === r && !e.params.loop) {
		d !== l && (e.snapIndex = d,
		e.emit("snapIndexChange"));
		return
	}
	if (a === r && e.params.loop && e.virtual && e.params.virtual.enabled) {
		e.realIndex = c(a);
		return
	}
	const p = e.grid && n.grid && n.grid.rows > 1;
	let h;
	if (e.virtual && n.virtual.enabled && n.loop)
		h = c(a);
	else if (p) {
		const m = e.slides.filter(S=>S.column === a)[0];
		let v = parseInt(m.getAttribute("data-swiper-slide-index"), 10);
		Number.isNaN(v) && (v = Math.max(e.slides.indexOf(m), 0)),
		h = Math.floor(v / n.grid.rows)
	} else if (e.slides[a]) {
		const m = e.slides[a].getAttribute("data-swiper-slide-index");
		m ? h = parseInt(m, 10) : h = a
	} else
		h = a;
	Object.assign(e, {
		previousSnapIndex: l,
		snapIndex: d,
		previousRealIndex: o,
		realIndex: h,
		previousIndex: r,
		activeIndex: a
	}),
	e.initialized && de(e),
	e.emit("activeIndexChange"),
	e.emit("snapIndexChange"),
	(e.initialized || e.params.runCallbacksOnInit) && (o !== h && e.emit("realIndexChange"),
	e.emit("slideChange"))
}
function at(i, e) {
	const t = this
	  , s = t.params;
	let n = i.closest(`.${s.slideClass}, swiper-slide`);
	!n && t.isElement && e && e.length > 1 && e.includes(i) && [...e.slice(e.indexOf(i) + 1, e.length)].forEach(l=>{
		!n && l.matches && l.matches(`.${s.slideClass}, swiper-slide`) && (n = l)
	}
	);
	let r = !1, o;
	if (n) {
		for (let l = 0; l < t.slides.length; l += 1)
			if (t.slides[l] === n) {
				r = !0,
				o = l;
				break
			}
	}
	if (n && r)
		t.clickedSlide = n,
		t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(n.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = o;
	else {
		t.clickedSlide = void 0,
		t.clickedIndex = void 0;
		return
	}
	s.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
}
var lt = {
	updateSize: Je,
	updateSlides: Qe,
	updateAutoHeight: Ze,
	updateSlidesOffset: et,
	updateSlidesProgress: tt,
	updateProgress: it,
	updateSlidesClasses: st,
	updateActiveIndex: nt,
	updateClickedSlide: at
};
function ot(i) {
	i === void 0 && (i = this.isHorizontal() ? "x" : "y");
	const e = this
	  , {params: t, rtlTranslate: s, translate: n, wrapperEl: r} = e;
	if (t.virtualTranslate)
		return s ? -n : n;
	if (t.cssMode)
		return n;
	let o = Fe(r, i);
	return o += e.cssOverflowAdjustment(),
	s && (o = -o),
	o || 0
}
function dt(i, e) {
	const t = this
	  , {rtlTranslate: s, params: n, wrapperEl: r, progress: o} = t;
	let l = 0
	  , a = 0;
	const d = 0;
	t.isHorizontal() ? l = s ? -i : i : a = i,
	n.roundLengths && (l = Math.floor(l),
	a = Math.floor(a)),
	t.previousTranslate = t.translate,
	t.translate = t.isHorizontal() ? l : a,
	n.cssMode ? r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -l : -a : n.virtualTranslate || (t.isHorizontal() ? l -= t.cssOverflowAdjustment() : a -= t.cssOverflowAdjustment(),
	r.style.transform = `translate3d(${l}px, ${a}px, ${d}px)`);
	let c;
	const p = t.maxTranslate() - t.minTranslate();
	p === 0 ? c = 0 : c = (i - t.minTranslate()) / p,
	c !== o && t.updateProgress(i),
	t.emit("setTranslate", t.translate, e)
}
function ct() {
	return -this.snapGrid[0]
}
function ut() {
	return -this.snapGrid[this.snapGrid.length - 1]
}
function ft(i, e, t, s, n) {
	i === void 0 && (i = 0),
	e === void 0 && (e = this.params.speed),
	t === void 0 && (t = !0),
	s === void 0 && (s = !0);
	const r = this
	  , {params: o, wrapperEl: l} = r;
	if (r.animating && o.preventInteractionOnTransition)
		return !1;
	const a = r.minTranslate()
	  , d = r.maxTranslate();
	let c;
	if (s && i > a ? c = a : s && i < d ? c = d : c = i,
	r.updateProgress(c),
	o.cssMode) {
		const p = r.isHorizontal();
		if (e === 0)
			l[p ? "scrollLeft" : "scrollTop"] = -c;
		else {
			if (!r.support.smoothScroll)
				return Ce({
					swiper: r,
					targetPosition: -c,
					side: p ? "left" : "top"
				}),
				!0;
			l.scrollTo({
				[p ? "left" : "top"]: -c,
				behavior: "smooth"
			})
		}
		return !0
	}
	return e === 0 ? (r.setTransition(0),
	r.setTranslate(c),
	t && (r.emit("beforeTransitionStart", e, n),
	r.emit("transitionEnd"))) : (r.setTransition(e),
	r.setTranslate(c),
	t && (r.emit("beforeTransitionStart", e, n),
	r.emit("transitionStart")),
	r.animating || (r.animating = !0,
	r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(h) {
		!r || r.destroyed || h.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd),
		r.onTranslateToWrapperTransitionEnd = null,
		delete r.onTranslateToWrapperTransitionEnd,
		t && r.emit("transitionEnd"))
	}
	),
	r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))),
	!0
}
var pt = {
	getTranslate: ot,
	setTranslate: dt,
	minTranslate: ct,
	maxTranslate: ut,
	translateTo: ft
};
function mt(i, e) {
	const t = this;
	t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${i}ms`,
	t.wrapperEl.style.transitionDelay = i === 0 ? "0ms" : ""),
	t.emit("setTransition", i, e)
}
function Le(i) {
	let {swiper: e, runCallbacks: t, direction: s, step: n} = i;
	const {activeIndex: r, previousIndex: o} = e;
	let l = s;
	if (l || (r > o ? l = "next" : r < o ? l = "prev" : l = "reset"),
	e.emit(`transition${n}`),
	t && r !== o) {
		if (l === "reset") {
			e.emit(`slideResetTransition${n}`);
			return
		}
		e.emit(`slideChangeTransition${n}`),
		l === "next" ? e.emit(`slideNextTransition${n}`) : e.emit(`slidePrevTransition${n}`)
	}
}
function ht(i, e) {
	i === void 0 && (i = !0);
	const t = this
	  , {params: s} = t;
	s.cssMode || (s.autoHeight && t.updateAutoHeight(),
	Le({
		swiper: t,
		runCallbacks: i,
		direction: e,
		step: "Start"
	}))
}
function gt(i, e) {
	i === void 0 && (i = !0);
	const t = this
	  , {params: s} = t;
	t.animating = !1,
	!s.cssMode && (t.setTransition(0),
	Le({
		swiper: t,
		runCallbacks: i,
		direction: e,
		step: "End"
	}))
}
var vt = {
	setTransition: mt,
	transitionStart: ht,
	transitionEnd: gt
};
function wt(i, e, t, s, n) {
	i === void 0 && (i = 0),
	e === void 0 && (e = this.params.speed),
	t === void 0 && (t = !0),
	typeof i == "string" && (i = parseInt(i, 10));
	const r = this;
	let o = i;
	o < 0 && (o = 0);
	const {params: l, snapGrid: a, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: h, wrapperEl: m, enabled: v} = r;
	if (r.animating && l.preventInteractionOnTransition || !v && !s && !n)
		return !1;
	const S = Math.min(r.params.slidesPerGroupSkip, o);
	let E = S + Math.floor((o - S) / r.params.slidesPerGroup);
	E >= a.length && (E = a.length - 1);
	const w = -a[E];
	if (l.normalizeSlideIndex)
		for (let f = 0; f < d.length; f += 1) {
			const g = -Math.floor(w * 100)
			  , T = Math.floor(d[f] * 100)
			  , C = Math.floor(d[f + 1] * 100);
			typeof d[f + 1] < "u" ? g >= T && g < C - (C - T) / 2 ? o = f : g >= T && g < C && (o = f + 1) : g >= T && (o = f)
		}
	if (r.initialized && o !== p && (!r.allowSlideNext && (h ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate()) || !r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== o))
		return !1;
	o !== (c || 0) && t && r.emit("beforeSlideChangeStart"),
	r.updateProgress(w);
	let u;
	if (o > p ? u = "next" : o < p ? u = "prev" : u = "reset",
	h && -w === r.translate || !h && w === r.translate)
		return r.updateActiveIndex(o),
		l.autoHeight && r.updateAutoHeight(),
		r.updateSlidesClasses(),
		l.effect !== "slide" && r.setTranslate(w),
		u !== "reset" && (r.transitionStart(t, u),
		r.transitionEnd(t, u)),
		!1;
	if (l.cssMode) {
		const f = r.isHorizontal()
		  , g = h ? w : -w;
		if (e === 0) {
			const T = r.virtual && r.params.virtual.enabled;
			T && (r.wrapperEl.style.scrollSnapType = "none",
			r._immediateVirtual = !0),
			T && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0,
			requestAnimationFrame(()=>{
				m[f ? "scrollLeft" : "scrollTop"] = g
			}
			)) : m[f ? "scrollLeft" : "scrollTop"] = g,
			T && requestAnimationFrame(()=>{
				r.wrapperEl.style.scrollSnapType = "",
				r._immediateVirtual = !1
			}
			)
		} else {
			if (!r.support.smoothScroll)
				return Ce({
					swiper: r,
					targetPosition: g,
					side: f ? "left" : "top"
				}),
				!0;
			m.scrollTo({
				[f ? "left" : "top"]: g,
				behavior: "smooth"
			})
		}
		return !0
	}
	return r.setTransition(e),
	r.setTranslate(w),
	r.updateActiveIndex(o),
	r.updateSlidesClasses(),
	r.emit("beforeTransitionStart", e, s),
	r.transitionStart(t, u),
	e === 0 ? r.transitionEnd(t, u) : r.animating || (r.animating = !0,
	r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(g) {
		!r || r.destroyed || g.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd),
		r.onSlideToWrapperTransitionEnd = null,
		delete r.onSlideToWrapperTransitionEnd,
		r.transitionEnd(t, u))
	}
	),
	r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)),
	!0
}
function yt(i, e, t, s) {
	i === void 0 && (i = 0),
	e === void 0 && (e = this.params.speed),
	t === void 0 && (t = !0),
	typeof i == "string" && (i = parseInt(i, 10));
	const n = this
	  , r = n.grid && n.params.grid && n.params.grid.rows > 1;
	let o = i;
	if (n.params.loop)
		if (n.virtual && n.params.virtual.enabled)
			o = o + n.virtual.slidesBefore;
		else {
			let l;
			if (r) {
				const h = o * n.params.grid.rows;
				l = n.slides.filter(m=>m.getAttribute("data-swiper-slide-index") * 1 === h)[0].column
			} else
				l = n.getSlideIndexByData(o);
			const a = r ? Math.ceil(n.slides.length / n.params.grid.rows) : n.slides.length
			  , {centeredSlides: d} = n.params;
			let c = n.params.slidesPerView;
			c === "auto" ? c = n.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(n.params.slidesPerView, 10)),
			d && c % 2 === 0 && (c = c + 1));
			let p = a - l < c;
			if (d && (p = p || l < Math.ceil(c / 2)),
			p) {
				const h = d ? l < n.activeIndex ? "prev" : "next" : l - n.activeIndex - 1 < n.params.slidesPerView ? "next" : "prev";
				n.loopFix({
					direction: h,
					slideTo: !0,
					activeSlideIndex: h === "next" ? l + 1 : l - a + 1,
					slideRealIndex: h === "next" ? n.realIndex : void 0
				})
			}
			if (r) {
				const h = o * n.params.grid.rows;
				o = n.slides.filter(m=>m.getAttribute("data-swiper-slide-index") * 1 === h)[0].column
			} else
				o = n.getSlideIndexByData(o)
		}
	return requestAnimationFrame(()=>{
		n.slideTo(o, e, t, s)
	}
	),
	n
}
function St(i, e, t) {
	i === void 0 && (i = this.params.speed),
	e === void 0 && (e = !0);
	const s = this
	  , {enabled: n, params: r, animating: o} = s;
	if (!n)
		return s;
	let l = r.slidesPerGroup;
	r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (l = Math.max(s.slidesPerViewDynamic("current", !0), 1));
	const a = s.activeIndex < r.slidesPerGroupSkip ? 1 : l
	  , d = s.virtual && r.virtual.enabled;
	if (r.loop) {
		if (o && !d && r.loopPreventsSliding)
			return !1;
		if (s.loopFix({
			direction: "next"
		}),
		s._clientLeft = s.wrapperEl.clientLeft,
		s.activeIndex === s.slides.length - 1 && r.cssMode)
			return requestAnimationFrame(()=>{
				s.slideTo(s.activeIndex + a, i, e, t)
			}
			),
			!0
	}
	return r.rewind && s.isEnd ? s.slideTo(0, i, e, t) : s.slideTo(s.activeIndex + a, i, e, t)
}
function Tt(i, e, t) {
	i === void 0 && (i = this.params.speed),
	e === void 0 && (e = !0);
	const s = this
	  , {params: n, snapGrid: r, slidesGrid: o, rtlTranslate: l, enabled: a, animating: d} = s;
	if (!a)
		return s;
	const c = s.virtual && n.virtual.enabled;
	if (n.loop) {
		if (d && !c && n.loopPreventsSliding)
			return !1;
		s.loopFix({
			direction: "prev"
		}),
		s._clientLeft = s.wrapperEl.clientLeft
	}
	const p = l ? s.translate : -s.translate;
	function h(w) {
		return w < 0 ? -Math.floor(Math.abs(w)) : Math.floor(w)
	}
	const m = h(p)
	  , v = r.map(w=>h(w));
	let S = r[v.indexOf(m) - 1];
	if (typeof S > "u" && n.cssMode) {
		let w;
		r.forEach((u,f)=>{
			m >= u && (w = f)
		}
		),
		typeof w < "u" && (S = r[w > 0 ? w - 1 : w])
	}
	let E = 0;
	if (typeof S < "u" && (E = o.indexOf(S),
	E < 0 && (E = s.activeIndex - 1),
	n.slidesPerView === "auto" && n.slidesPerGroup === 1 && n.slidesPerGroupAuto && (E = E - s.slidesPerViewDynamic("previous", !0) + 1,
	E = Math.max(E, 0))),
	n.rewind && s.isBeginning) {
		const w = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1;
		return s.slideTo(w, i, e, t)
	} else if (n.loop && s.activeIndex === 0 && n.cssMode)
		return requestAnimationFrame(()=>{
			s.slideTo(E, i, e, t)
		}
		),
		!0;
	return s.slideTo(E, i, e, t)
}
function bt(i, e, t) {
	i === void 0 && (i = this.params.speed),
	e === void 0 && (e = !0);
	const s = this;
	return s.slideTo(s.activeIndex, i, e, t)
}
function xt(i, e, t, s) {
	i === void 0 && (i = this.params.speed),
	e === void 0 && (e = !0),
	s === void 0 && (s = .5);
	const n = this;
	let r = n.activeIndex;
	const o = Math.min(n.params.slidesPerGroupSkip, r)
	  , l = o + Math.floor((r - o) / n.params.slidesPerGroup)
	  , a = n.rtlTranslate ? n.translate : -n.translate;
	if (a >= n.snapGrid[l]) {
		const d = n.snapGrid[l]
		  , c = n.snapGrid[l + 1];
		a - d > (c - d) * s && (r += n.params.slidesPerGroup)
	} else {
		const d = n.snapGrid[l - 1]
		  , c = n.snapGrid[l];
		a - d <= (c - d) * s && (r -= n.params.slidesPerGroup)
	}
	return r = Math.max(r, 0),
	r = Math.min(r, n.slidesGrid.length - 1),
	n.slideTo(r, i, e, t)
}
function Et() {
	const i = this
	  , {params: e, slidesEl: t} = i
	  , s = e.slidesPerView === "auto" ? i.slidesPerViewDynamic() : e.slidesPerView;
	let n = i.clickedIndex, r;
	const o = i.isElement ? "swiper-slide" : `.${e.slideClass}`;
	if (e.loop) {
		if (i.animating)
			return;
		r = parseInt(i.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
		e.centeredSlides ? n < i.loopedSlides - s / 2 || n > i.slides.length - i.loopedSlides + s / 2 ? (i.loopFix(),
		n = i.getSlideIndex(F(t, `${o}[data-swiper-slide-index="${r}"]`)[0]),
		le(()=>{
			i.slideTo(n)
		}
		)) : i.slideTo(n) : n > i.slides.length - s ? (i.loopFix(),
		n = i.getSlideIndex(F(t, `${o}[data-swiper-slide-index="${r}"]`)[0]),
		le(()=>{
			i.slideTo(n)
		}
		)) : i.slideTo(n)
	} else
		i.slideTo(n)
}
var Ct = {
	slideTo: wt,
	slideToLoop: yt,
	slideNext: St,
	slidePrev: Tt,
	slideReset: bt,
	slideToClosest: xt,
	slideToClickedSlide: Et
};
function Mt(i) {
	const e = this
	  , {params: t, slidesEl: s} = e;
	if (!t.loop || e.virtual && e.params.virtual.enabled)
		return;
	const n = ()=>{
		F(s, `.${t.slideClass}, swiper-slide`).forEach((p,h)=>{
			p.setAttribute("data-swiper-slide-index", h)
		}
		)
	}
	  , r = e.grid && t.grid && t.grid.rows > 1
	  , o = t.slidesPerGroup * (r ? t.grid.rows : 1)
	  , l = e.slides.length % o !== 0
	  , a = r && e.slides.length % t.grid.rows !== 0
	  , d = c=>{
		for (let p = 0; p < c; p += 1) {
			const h = e.isElement ? Q("swiper-slide", [t.slideBlankClass]) : Q("div", [t.slideClass, t.slideBlankClass]);
			e.slidesEl.append(h)
		}
	}
	;
	if (l) {
		if (t.loopAddBlankSlides) {
			const c = o - e.slides.length % o;
			d(c),
			e.recalcSlides(),
			e.updateSlides()
		} else
			J("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
		n()
	} else if (a) {
		if (t.loopAddBlankSlides) {
			const c = t.grid.rows - e.slides.length % t.grid.rows;
			d(c),
			e.recalcSlides(),
			e.updateSlides()
		} else
			J("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
		n()
	} else
		n();
	e.loopFix({
		slideRealIndex: i,
		direction: t.centeredSlides ? void 0 : "next"
	})
}
function Pt(i) {
	let {slideRealIndex: e, slideTo: t=!0, direction: s, setTranslate: n, activeSlideIndex: r, byController: o, byMousewheel: l} = i === void 0 ? {} : i;
	const a = this;
	if (!a.params.loop)
		return;
	a.emit("beforeLoopFix");
	const {slides: d, allowSlidePrev: c, allowSlideNext: p, slidesEl: h, params: m} = a
	  , {centeredSlides: v} = m;
	if (a.allowSlidePrev = !0,
	a.allowSlideNext = !0,
	a.virtual && m.virtual.enabled) {
		t && (!m.centeredSlides && a.snapIndex === 0 ? a.slideTo(a.virtual.slides.length, 0, !1, !0) : m.centeredSlides && a.snapIndex < m.slidesPerView ? a.slideTo(a.virtual.slides.length + a.snapIndex, 0, !1, !0) : a.snapIndex === a.snapGrid.length - 1 && a.slideTo(a.virtual.slidesBefore, 0, !1, !0)),
		a.allowSlidePrev = c,
		a.allowSlideNext = p,
		a.emit("loopFix");
		return
	}
	let S = m.slidesPerView;
	S === "auto" ? S = a.slidesPerViewDynamic() : (S = Math.ceil(parseFloat(m.slidesPerView, 10)),
	v && S % 2 === 0 && (S = S + 1));
	const E = m.slidesPerGroupAuto ? S : m.slidesPerGroup;
	let w = E;
	w % E !== 0 && (w += E - w % E),
	w += m.loopAdditionalSlides,
	a.loopedSlides = w;
	const u = a.grid && m.grid && m.grid.rows > 1;
	d.length < S + w ? J("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : u && m.grid.fill === "row" && J("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
	const f = []
	  , g = [];
	let T = a.activeIndex;
	typeof r > "u" ? r = a.getSlideIndex(d.filter(b=>b.classList.contains(m.slideActiveClass))[0]) : T = r;
	const C = s === "next" || !s
	  , z = s === "prev" || !s;
	let A = 0
	  , L = 0;
	const y = u ? Math.ceil(d.length / m.grid.rows) : d.length
	  , M = (u ? d[r].column : r) + (v && typeof n > "u" ? -S / 2 + .5 : 0);
	if (M < w) {
		A = Math.max(w - M, E);
		for (let b = 0; b < w - M; b += 1) {
			const P = b - Math.floor(b / y) * y;
			if (u) {
				const I = y - P - 1;
				for (let D = d.length - 1; D >= 0; D -= 1)
					d[D].column === I && f.push(D)
			} else
				f.push(y - P - 1)
		}
	} else if (M + S > y - w) {
		L = Math.max(M - (y - w * 2), E);
		for (let b = 0; b < L; b += 1) {
			const P = b - Math.floor(b / y) * y;
			u ? d.forEach((I,D)=>{
				I.column === P && g.push(D)
			}
			) : g.push(P)
		}
	}
	if (a.__preventObserver__ = !0,
	requestAnimationFrame(()=>{
		a.__preventObserver__ = !1
	}
	),
	z && f.forEach(b=>{
		d[b].swiperLoopMoveDOM = !0,
		h.prepend(d[b]),
		d[b].swiperLoopMoveDOM = !1
	}
	),
	C && g.forEach(b=>{
		d[b].swiperLoopMoveDOM = !0,
		h.append(d[b]),
		d[b].swiperLoopMoveDOM = !1
	}
	),
	a.recalcSlides(),
	m.slidesPerView === "auto" ? a.updateSlides() : u && (f.length > 0 && z || g.length > 0 && C) && a.slides.forEach((b,P)=>{
		a.grid.updateSlide(P, b, a.slides)
	}
	),
	m.watchSlidesProgress && a.updateSlidesOffset(),
	t) {
		if (f.length > 0 && z) {
			if (typeof e > "u") {
				const b = a.slidesGrid[T]
				  , I = a.slidesGrid[T + A] - b;
				l ? a.setTranslate(a.translate - I) : (a.slideTo(T + A, 0, !1, !0),
				n && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - I,
				a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - I))
			} else if (n) {
				const b = u ? f.length / m.grid.rows : f.length;
				a.slideTo(a.activeIndex + b, 0, !1, !0),
				a.touchEventsData.currentTranslate = a.translate
			}
		} else if (g.length > 0 && C)
			if (typeof e > "u") {
				const b = a.slidesGrid[T]
				  , I = a.slidesGrid[T - L] - b;
				l ? a.setTranslate(a.translate - I) : (a.slideTo(T - L, 0, !1, !0),
				n && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - I,
				a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - I))
			} else {
				const b = u ? g.length / m.grid.rows : g.length;
				a.slideTo(a.activeIndex - b, 0, !1, !0)
			}
	}
	if (a.allowSlidePrev = c,
	a.allowSlideNext = p,
	a.controller && a.controller.control && !o) {
		const b = {
			slideRealIndex: e,
			direction: s,
			setTranslate: n,
			activeSlideIndex: r,
			byController: !0
		};
		Array.isArray(a.controller.control) ? a.controller.control.forEach(P=>{
			!P.destroyed && P.params.loop && P.loopFix({
				...b,
				slideTo: P.params.slidesPerView === m.slidesPerView ? t : !1
			})
		}
		) : a.controller.control instanceof a.constructor && a.controller.control.params.loop && a.controller.control.loopFix({
			...b,
			slideTo: a.controller.control.params.slidesPerView === m.slidesPerView ? t : !1
		})
	}
	a.emit("loopFix")
}
function Lt() {
	const i = this
	  , {params: e, slidesEl: t} = i;
	if (!e.loop || i.virtual && i.params.virtual.enabled)
		return;
	i.recalcSlides();
	const s = [];
	i.slides.forEach(n=>{
		const r = typeof n.swiperSlideIndex > "u" ? n.getAttribute("data-swiper-slide-index") * 1 : n.swiperSlideIndex;
		s[r] = n
	}
	),
	i.slides.forEach(n=>{
		n.removeAttribute("data-swiper-slide-index")
	}
	),
	s.forEach(n=>{
		t.append(n)
	}
	),
	i.recalcSlides(),
	i.slideTo(i.realIndex, 0)
}
var It = {
	loopCreate: Mt,
	loopFix: Pt,
	loopDestroy: Lt
};
function At(i) {
	const e = this;
	if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode)
		return;
	const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
	e.isElement && (e.__preventObserver__ = !0),
	t.style.cursor = "move",
	t.style.cursor = i ? "grabbing" : "grab",
	e.isElement && requestAnimationFrame(()=>{
		e.__preventObserver__ = !1
	}
	)
}
function Ot() {
	const i = this;
	i.params.watchOverflow && i.isLocked || i.params.cssMode || (i.isElement && (i.__preventObserver__ = !0),
	i[i.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
	i.isElement && requestAnimationFrame(()=>{
		i.__preventObserver__ = !1
	}
	))
}
var zt = {
	setGrabCursor: At,
	unsetGrabCursor: Ot
};
function Dt(i, e) {
	e === void 0 && (e = this);
	function t(s) {
		if (!s || s === _() || s === $())
			return null;
		s.assignedSlot && (s = s.assignedSlot);
		const n = s.closest(i);
		return !n && !s.getRootNode ? null : n || t(s.getRootNode().host)
	}
	return t(e)
}
function me(i, e, t) {
	const s = $()
	  , {params: n} = i
	  , r = n.edgeSwipeDetection
	  , o = n.edgeSwipeThreshold;
	return r && (t <= o || t >= s.innerWidth - o) ? r === "prevent" ? (e.preventDefault(),
	!0) : !1 : !0
}
function kt(i) {
	const e = this
	  , t = _();
	let s = i;
	s.originalEvent && (s = s.originalEvent);
	const n = e.touchEventsData;
	if (s.type === "pointerdown") {
		if (n.pointerId !== null && n.pointerId !== s.pointerId)
			return;
		n.pointerId = s.pointerId
	} else
		s.type === "touchstart" && s.targetTouches.length === 1 && (n.touchId = s.targetTouches[0].identifier);
	if (s.type === "touchstart") {
		me(e, s, s.targetTouches[0].pageX);
		return
	}
	const {params: r, touches: o, enabled: l} = e;
	if (!l || !r.simulateTouch && s.pointerType === "mouse" || e.animating && r.preventInteractionOnTransition)
		return;
	!e.animating && r.cssMode && r.loop && e.loopFix();
	let a = s.target;
	if (r.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(a) || "which"in s && s.which === 3 || "button"in s && s.button > 0 || n.isTouched && n.isMoved)
		return;
	const d = !!r.noSwipingClass && r.noSwipingClass !== ""
	  , c = s.composedPath ? s.composedPath() : s.path;
	d && s.target && s.target.shadowRoot && c && (a = c[0]);
	const p = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`
	  , h = !!(s.target && s.target.shadowRoot);
	if (r.noSwiping && (h ? Dt(p, a) : a.closest(p))) {
		e.allowClick = !0;
		return
	}
	if (r.swipeHandler && !a.closest(r.swipeHandler))
		return;
	o.currentX = s.pageX,
	o.currentY = s.pageY;
	const m = o.currentX
	  , v = o.currentY;
	if (!me(e, s, m))
		return;
	Object.assign(n, {
		isTouched: !0,
		isMoved: !1,
		allowTouchCallbacks: !0,
		isScrolling: void 0,
		startMoving: void 0
	}),
	o.startX = m,
	o.startY = v,
	n.touchStartTime = U(),
	e.allowClick = !0,
	e.updateSize(),
	e.swipeDirection = void 0,
	r.threshold > 0 && (n.allowThresholdMove = !1);
	let S = !0;
	a.matches(n.focusableElements) && (S = !1,
	a.nodeName === "SELECT" && (n.isTouched = !1)),
	t.activeElement && t.activeElement.matches(n.focusableElements) && t.activeElement !== a && t.activeElement.blur();
	const E = S && e.allowTouchMove && r.touchStartPreventDefault;
	(r.touchStartForcePreventDefault || E) && !a.isContentEditable && s.preventDefault(),
	r.freeMode && r.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(),
	e.emit("touchStart", s)
}
function Gt(i) {
	const e = _()
	  , t = this
	  , s = t.touchEventsData
	  , {params: n, touches: r, rtlTranslate: o, enabled: l} = t;
	if (!l || !n.simulateTouch && i.pointerType === "mouse")
		return;
	let a = i;
	if (a.originalEvent && (a = a.originalEvent),
	a.type === "pointermove" && (s.touchId !== null || a.pointerId !== s.pointerId))
		return;
	let d;
	if (a.type === "touchmove") {
		if (d = [...a.changedTouches].filter(C=>C.identifier === s.touchId)[0],
		!d || d.identifier !== s.touchId)
			return
	} else
		d = a;
	if (!s.isTouched) {
		s.startMoving && s.isScrolling && t.emit("touchMoveOpposite", a);
		return
	}
	const c = d.pageX
	  , p = d.pageY;
	if (a.preventedByNestedSwiper) {
		r.startX = c,
		r.startY = p;
		return
	}
	if (!t.allowTouchMove) {
		a.target.matches(s.focusableElements) || (t.allowClick = !1),
		s.isTouched && (Object.assign(r, {
			startX: c,
			startY: p,
			currentX: c,
			currentY: p
		}),
		s.touchStartTime = U());
		return
	}
	if (n.touchReleaseOnEdges && !n.loop) {
		if (t.isVertical()) {
			if (p < r.startY && t.translate <= t.maxTranslate() || p > r.startY && t.translate >= t.minTranslate()) {
				s.isTouched = !1,
				s.isMoved = !1;
				return
			}
		} else if (c < r.startX && t.translate <= t.maxTranslate() || c > r.startX && t.translate >= t.minTranslate())
			return
	}
	if (e.activeElement && a.target === e.activeElement && a.target.matches(s.focusableElements)) {
		s.isMoved = !0,
		t.allowClick = !1;
		return
	}
	s.allowTouchCallbacks && t.emit("touchMove", a),
	r.previousX = r.currentX,
	r.previousY = r.currentY,
	r.currentX = c,
	r.currentY = p;
	const h = r.currentX - r.startX
	  , m = r.currentY - r.startY;
	if (t.params.threshold && Math.sqrt(h ** 2 + m ** 2) < t.params.threshold)
		return;
	if (typeof s.isScrolling > "u") {
		let C;
		t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? s.isScrolling = !1 : h * h + m * m >= 25 && (C = Math.atan2(Math.abs(m), Math.abs(h)) * 180 / Math.PI,
		s.isScrolling = t.isHorizontal() ? C > n.touchAngle : 90 - C > n.touchAngle)
	}
	if (s.isScrolling && t.emit("touchMoveOpposite", a),
	typeof s.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (s.startMoving = !0),
	s.isScrolling) {
		s.isTouched = !1;
		return
	}
	if (!s.startMoving)
		return;
	t.allowClick = !1,
	!n.cssMode && a.cancelable && a.preventDefault(),
	n.touchMoveStopPropagation && !n.nested && a.stopPropagation();
	let v = t.isHorizontal() ? h : m
	  , S = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
	n.oneWayMovement && (v = Math.abs(v) * (o ? 1 : -1),
	S = Math.abs(S) * (o ? 1 : -1)),
	r.diff = v,
	v *= n.touchRatio,
	o && (v = -v,
	S = -S);
	const E = t.touchesDirection;
	t.swipeDirection = v > 0 ? "prev" : "next",
	t.touchesDirection = S > 0 ? "prev" : "next";
	const w = t.params.loop && !n.cssMode
	  , u = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
	if (!s.isMoved) {
		if (w && u && t.loopFix({
			direction: t.swipeDirection
		}),
		s.startTranslate = t.getTranslate(),
		t.setTransition(0),
		t.animating) {
			const C = new window.CustomEvent("transitionend",{
				bubbles: !0,
				cancelable: !0
			});
			t.wrapperEl.dispatchEvent(C)
		}
		s.allowMomentumBounce = !1,
		n.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0),
		t.emit("sliderFirstMove", a)
	}
	let f;
	if (new Date().getTime(),
	s.isMoved && s.allowThresholdMove && E !== t.touchesDirection && w && u && Math.abs(v) >= 1) {
		Object.assign(r, {
			startX: c,
			startY: p,
			currentX: c,
			currentY: p,
			startTranslate: s.currentTranslate
		}),
		s.loopSwapReset = !0,
		s.startTranslate = s.currentTranslate;
		return
	}
	t.emit("sliderMove", a),
	s.isMoved = !0,
	s.currentTranslate = v + s.startTranslate;
	let g = !0
	  , T = n.resistanceRatio;
	if (n.touchReleaseOnEdges && (T = 0),
	v > 0 ? (w && u && !f && s.allowThresholdMove && s.currentTranslate > (n.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({
		direction: "prev",
		setTranslate: !0,
		activeSlideIndex: 0
	}),
	s.currentTranslate > t.minTranslate() && (g = !1,
	n.resistance && (s.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + s.startTranslate + v) ** T))) : v < 0 && (w && u && !f && s.allowThresholdMove && s.currentTranslate < (n.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({
		direction: "next",
		setTranslate: !0,
		activeSlideIndex: t.slides.length - (n.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(n.slidesPerView, 10)))
	}),
	s.currentTranslate < t.maxTranslate() && (g = !1,
	n.resistance && (s.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - s.startTranslate - v) ** T))),
	g && (a.preventedByNestedSwiper = !0),
	!t.allowSlideNext && t.swipeDirection === "next" && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate),
	!t.allowSlidePrev && t.swipeDirection === "prev" && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate),
	!t.allowSlidePrev && !t.allowSlideNext && (s.currentTranslate = s.startTranslate),
	n.threshold > 0)
		if (Math.abs(v) > n.threshold || s.allowThresholdMove) {
			if (!s.allowThresholdMove) {
				s.allowThresholdMove = !0,
				r.startX = r.currentX,
				r.startY = r.currentY,
				s.currentTranslate = s.startTranslate,
				r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY;
				return
			}
		} else {
			s.currentTranslate = s.startTranslate;
			return
		}
	!n.followFinger || n.cssMode || ((n.freeMode && n.freeMode.enabled && t.freeMode || n.watchSlidesProgress) && (t.updateActiveIndex(),
	t.updateSlidesClasses()),
	n.freeMode && n.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(),
	t.updateProgress(s.currentTranslate),
	t.setTranslate(s.currentTranslate))
}
function $t(i) {
	const e = this
	  , t = e.touchEventsData;
	let s = i;
	s.originalEvent && (s = s.originalEvent);
	let n;
	if (s.type === "touchend" || s.type === "touchcancel") {
		if (n = [...s.changedTouches].filter(T=>T.identifier === t.touchId)[0],
		!n || n.identifier !== t.touchId)
			return
	} else {
		if (t.touchId !== null || s.pointerId !== t.pointerId)
			return;
		n = s
	}
	if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(s.type) && !(["pointercancel", "contextmenu"].includes(s.type) && (e.browser.isSafari || e.browser.isWebView)))
		return;
	t.pointerId = null,
	t.touchId = null;
	const {params: o, touches: l, rtlTranslate: a, slidesGrid: d, enabled: c} = e;
	if (!c || !o.simulateTouch && s.pointerType === "mouse")
		return;
	if (t.allowTouchCallbacks && e.emit("touchEnd", s),
	t.allowTouchCallbacks = !1,
	!t.isTouched) {
		t.isMoved && o.grabCursor && e.setGrabCursor(!1),
		t.isMoved = !1,
		t.startMoving = !1;
		return
	}
	o.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
	const p = U()
	  , h = p - t.touchStartTime;
	if (e.allowClick) {
		const T = s.path || s.composedPath && s.composedPath();
		e.updateClickedSlide(T && T[0] || s.target, T),
		e.emit("tap click", s),
		h < 300 && p - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", s)
	}
	if (t.lastClickTime = U(),
	le(()=>{
		e.destroyed || (e.allowClick = !0)
	}
	),
	!t.isTouched || !t.isMoved || !e.swipeDirection || l.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
		t.isTouched = !1,
		t.isMoved = !1,
		t.startMoving = !1;
		return
	}
	t.isTouched = !1,
	t.isMoved = !1,
	t.startMoving = !1;
	let m;
	if (o.followFinger ? m = a ? e.translate : -e.translate : m = -t.currentTranslate,
	o.cssMode)
		return;
	if (o.freeMode && o.freeMode.enabled) {
		e.freeMode.onTouchEnd({
			currentPos: m
		});
		return
	}
	const v = m >= -e.maxTranslate() && !e.params.loop;
	let S = 0
	  , E = e.slidesSizesGrid[0];
	for (let T = 0; T < d.length; T += T < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) {
		const C = T < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
		typeof d[T + C] < "u" ? (v || m >= d[T] && m < d[T + C]) && (S = T,
		E = d[T + C] - d[T]) : (v || m >= d[T]) && (S = T,
		E = d[d.length - 1] - d[d.length - 2])
	}
	let w = null
	  , u = null;
	o.rewind && (e.isBeginning ? u = o.virtual && o.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (w = 0));
	const f = (m - d[S]) / E
	  , g = S < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
	if (h > o.longSwipesMs) {
		if (!o.longSwipes) {
			e.slideTo(e.activeIndex);
			return
		}
		e.swipeDirection === "next" && (f >= o.longSwipesRatio ? e.slideTo(o.rewind && e.isEnd ? w : S + g) : e.slideTo(S)),
		e.swipeDirection === "prev" && (f > 1 - o.longSwipesRatio ? e.slideTo(S + g) : u !== null && f < 0 && Math.abs(f) > o.longSwipesRatio ? e.slideTo(u) : e.slideTo(S))
	} else {
		if (!o.shortSwipes) {
			e.slideTo(e.activeIndex);
			return
		}
		e.navigation && (s.target === e.navigation.nextEl || s.target === e.navigation.prevEl) ? s.target === e.navigation.nextEl ? e.slideTo(S + g) : e.slideTo(S) : (e.swipeDirection === "next" && e.slideTo(w !== null ? w : S + g),
		e.swipeDirection === "prev" && e.slideTo(u !== null ? u : S))
	}
}
function he() {
	const i = this
	  , {params: e, el: t} = i;
	if (t && t.offsetWidth === 0)
		return;
	e.breakpoints && i.setBreakpoint();
	const {allowSlideNext: s, allowSlidePrev: n, snapGrid: r} = i
	  , o = i.virtual && i.params.virtual.enabled;
	i.allowSlideNext = !0,
	i.allowSlidePrev = !0,
	i.updateSize(),
	i.updateSlides(),
	i.updateSlidesClasses();
	const l = o && e.loop;
	(e.slidesPerView === "auto" || e.slidesPerView > 1) && i.isEnd && !i.isBeginning && !i.params.centeredSlides && !l ? i.slideTo(i.slides.length - 1, 0, !1, !0) : i.params.loop && !o ? i.slideToLoop(i.realIndex, 0, !1, !0) : i.slideTo(i.activeIndex, 0, !1, !0),
	i.autoplay && i.autoplay.running && i.autoplay.paused && (clearTimeout(i.autoplay.resizeTimeout),
	i.autoplay.resizeTimeout = setTimeout(()=>{
		i.autoplay && i.autoplay.running && i.autoplay.paused && i.autoplay.resume()
	}
	, 500)),
	i.allowSlidePrev = n,
	i.allowSlideNext = s,
	i.params.watchOverflow && r !== i.snapGrid && i.checkOverflow()
}
function Vt(i) {
	const e = this;
	e.enabled && (e.allowClick || (e.params.preventClicks && i.preventDefault(),
	e.params.preventClicksPropagation && e.animating && (i.stopPropagation(),
	i.stopImmediatePropagation())))
}
function Bt() {
	const i = this
	  , {wrapperEl: e, rtlTranslate: t, enabled: s} = i;
	if (!s)
		return;
	i.previousTranslate = i.translate,
	i.isHorizontal() ? i.translate = -e.scrollLeft : i.translate = -e.scrollTop,
	i.translate === 0 && (i.translate = 0),
	i.updateActiveIndex(),
	i.updateSlidesClasses();
	let n;
	const r = i.maxTranslate() - i.minTranslate();
	r === 0 ? n = 0 : n = (i.translate - i.minTranslate()) / r,
	n !== i.progress && i.updateProgress(t ? -i.translate : i.translate),
	i.emit("setTranslate", i.translate, !1)
}
function Ft(i) {
	const e = this;
	K(e, i.target),
	!(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update()
}
function _t() {
	const i = this;
	i.documentTouchHandlerProceeded || (i.documentTouchHandlerProceeded = !0,
	i.params.touchReleaseOnEdges && (i.el.style.touchAction = "auto"))
}
const Ie = (i,e)=>{
	const t = _()
	  , {params: s, el: n, wrapperEl: r, device: o} = i
	  , l = !!s.nested
	  , a = e === "on" ? "addEventListener" : "removeEventListener"
	  , d = e;
	t[a]("touchstart", i.onDocumentTouchStart, {
		passive: !1,
		capture: l
	}),
	n[a]("touchstart", i.onTouchStart, {
		passive: !1
	}),
	n[a]("pointerdown", i.onTouchStart, {
		passive: !1
	}),
	t[a]("touchmove", i.onTouchMove, {
		passive: !1,
		capture: l
	}),
	t[a]("pointermove", i.onTouchMove, {
		passive: !1,
		capture: l
	}),
	t[a]("touchend", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("pointerup", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("pointercancel", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("touchcancel", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("pointerout", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("pointerleave", i.onTouchEnd, {
		passive: !0
	}),
	t[a]("contextmenu", i.onTouchEnd, {
		passive: !0
	}),
	(s.preventClicks || s.preventClicksPropagation) && n[a]("click", i.onClick, !0),
	s.cssMode && r[a]("scroll", i.onScroll),
	s.updateOnWindowResize ? i[d](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", he, !0) : i[d]("observerUpdate", he, !0),
	n[a]("load", i.onLoad, {
		capture: !0
	})
}
;
function Nt() {
	const i = this
	  , {params: e} = i;
	i.onTouchStart = kt.bind(i),
	i.onTouchMove = Gt.bind(i),
	i.onTouchEnd = $t.bind(i),
	i.onDocumentTouchStart = _t.bind(i),
	e.cssMode && (i.onScroll = Bt.bind(i)),
	i.onClick = Vt.bind(i),
	i.onLoad = Ft.bind(i),
	Ie(i, "on")
}
function Ht() {
	Ie(this, "off")
}
var Rt = {
	attachEvents: Nt,
	detachEvents: Ht
};
const ge = (i,e)=>i.grid && e.grid && e.grid.rows > 1;
function Wt() {
	const i = this
	  , {realIndex: e, initialized: t, params: s, el: n} = i
	  , r = s.breakpoints;
	if (!r || r && Object.keys(r).length === 0)
		return;
	const o = i.getBreakpoint(r, i.params.breakpointsBase, i.el);
	if (!o || i.currentBreakpoint === o)
		return;
	const a = (o in r ? r[o] : void 0) || i.originalParams
	  , d = ge(i, s)
	  , c = ge(i, a)
	  , p = s.enabled;
	d && !c ? (n.classList.remove(`${s.containerModifierClass}grid`, `${s.containerModifierClass}grid-column`),
	i.emitContainerClasses()) : !d && c && (n.classList.add(`${s.containerModifierClass}grid`),
	(a.grid.fill && a.grid.fill === "column" || !a.grid.fill && s.grid.fill === "column") && n.classList.add(`${s.containerModifierClass}grid-column`),
	i.emitContainerClasses()),
	["navigation", "pagination", "scrollbar"].forEach(w=>{
		if (typeof a[w] > "u")
			return;
		const u = s[w] && s[w].enabled
		  , f = a[w] && a[w].enabled;
		u && !f && i[w].disable(),
		!u && f && i[w].enable()
	}
	);
	const h = a.direction && a.direction !== s.direction
	  , m = s.loop && (a.slidesPerView !== s.slidesPerView || h)
	  , v = s.loop;
	h && t && i.changeDirection(),
	G(i.params, a);
	const S = i.params.enabled
	  , E = i.params.loop;
	Object.assign(i, {
		allowTouchMove: i.params.allowTouchMove,
		allowSlideNext: i.params.allowSlideNext,
		allowSlidePrev: i.params.allowSlidePrev
	}),
	p && !S ? i.disable() : !p && S && i.enable(),
	i.currentBreakpoint = o,
	i.emit("_beforeBreakpoint", a),
	t && (m ? (i.loopDestroy(),
	i.loopCreate(e),
	i.updateSlides()) : !v && E ? (i.loopCreate(e),
	i.updateSlides()) : v && !E && i.loopDestroy()),
	i.emit("breakpoint", a)
}
function Yt(i, e, t) {
	if (e === void 0 && (e = "window"),
	!i || e === "container" && !t)
		return;
	let s = !1;
	const n = $()
	  , r = e === "window" ? n.innerHeight : t.clientHeight
	  , o = Object.keys(i).map(l=>{
		if (typeof l == "string" && l.indexOf("@") === 0) {
			const a = parseFloat(l.substr(1));
			return {
				value: r * a,
				point: l
			}
		}
		return {
			value: l,
			point: l
		}
	}
	);
	o.sort((l,a)=>parseInt(l.value, 10) - parseInt(a.value, 10));
	for (let l = 0; l < o.length; l += 1) {
		const {point: a, value: d} = o[l];
		e === "window" ? n.matchMedia(`(min-width: ${d}px)`).matches && (s = a) : d <= t.clientWidth && (s = a)
	}
	return s || "max"
}
var jt = {
	setBreakpoint: Wt,
	getBreakpoint: Yt
};
function qt(i, e) {
	const t = [];
	return i.forEach(s=>{
		typeof s == "object" ? Object.keys(s).forEach(n=>{
			s[n] && t.push(e + n)
		}
		) : typeof s == "string" && t.push(e + s)
	}
	),
	t
}
function Xt() {
	const i = this
	  , {classNames: e, params: t, rtl: s, el: n, device: r} = i
	  , o = qt(["initialized", t.direction, {
		"free-mode": i.params.freeMode && t.freeMode.enabled
	}, {
		autoheight: t.autoHeight
	}, {
		rtl: s
	}, {
		grid: t.grid && t.grid.rows > 1
	}, {
		"grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
	}, {
		android: r.android
	}, {
		ios: r.ios
	}, {
		"css-mode": t.cssMode
	}, {
		centered: t.cssMode && t.centeredSlides
	}, {
		"watch-progress": t.watchSlidesProgress
	}], t.containerModifierClass);
	e.push(...o),
	n.classList.add(...e),
	i.emitContainerClasses()
}
function Kt() {
	const i = this
	  , {el: e, classNames: t} = i;
	e.classList.remove(...t),
	i.emitContainerClasses()
}
var Ut = {
	addClasses: Xt,
	removeClasses: Kt
};
function Jt() {
	const i = this
	  , {isLocked: e, params: t} = i
	  , {slidesOffsetBefore: s} = t;
	if (s) {
		const n = i.slides.length - 1
		  , r = i.slidesGrid[n] + i.slidesSizesGrid[n] + s * 2;
		i.isLocked = i.size > r
	} else
		i.isLocked = i.snapGrid.length === 1;
	t.allowSlideNext === !0 && (i.allowSlideNext = !i.isLocked),
	t.allowSlidePrev === !0 && (i.allowSlidePrev = !i.isLocked),
	e && e !== i.isLocked && (i.isEnd = !1),
	e !== i.isLocked && i.emit(i.isLocked ? "lock" : "unlock")
}
var Qt = {
	checkOverflow: Jt
}
  , ve = {
	init: !0,
	direction: "horizontal",
	oneWayMovement: !1,
	touchEventsTarget: "wrapper",
	initialSlide: 0,
	speed: 300,
	cssMode: !1,
	updateOnWindowResize: !0,
	resizeObserver: !0,
	nested: !1,
	createElements: !1,
	eventsPrefix: "swiper",
	enabled: !0,
	focusableElements: "input, select, option, textarea, button, video, label",
	width: null,
	height: null,
	preventInteractionOnTransition: !1,
	userAgent: null,
	url: null,
	edgeSwipeDetection: !1,
	edgeSwipeThreshold: 20,
	autoHeight: !1,
	setWrapperSize: !1,
	virtualTranslate: !1,
	effect: "slide",
	breakpoints: void 0,
	breakpointsBase: "window",
	spaceBetween: 0,
	slidesPerView: 1,
	slidesPerGroup: 1,
	slidesPerGroupSkip: 0,
	slidesPerGroupAuto: !1,
	centeredSlides: !1,
	centeredSlidesBounds: !1,
	slidesOffsetBefore: 0,
	slidesOffsetAfter: 0,
	normalizeSlideIndex: !0,
	centerInsufficientSlides: !1,
	watchOverflow: !0,
	roundLengths: !1,
	touchRatio: 1,
	touchAngle: 45,
	simulateTouch: !0,
	shortSwipes: !0,
	longSwipes: !0,
	longSwipesRatio: .5,
	longSwipesMs: 300,
	followFinger: !0,
	allowTouchMove: !0,
	threshold: 5,
	touchMoveStopPropagation: !1,
	touchStartPreventDefault: !0,
	touchStartForcePreventDefault: !1,
	touchReleaseOnEdges: !1,
	uniqueNavElements: !0,
	resistance: !0,
	resistanceRatio: .85,
	watchSlidesProgress: !1,
	grabCursor: !1,
	preventClicks: !0,
	preventClicksPropagation: !0,
	slideToClickedSlide: !1,
	loop: !1,
	loopAddBlankSlides: !0,
	loopAdditionalSlides: 0,
	loopPreventsSliding: !0,
	rewind: !1,
	allowSlidePrev: !0,
	allowSlideNext: !0,
	swipeHandler: null,
	noSwiping: !0,
	noSwipingClass: "swiper-no-swiping",
	noSwipingSelector: null,
	passiveListeners: !0,
	maxBackfaceHiddenSlides: 10,
	containerModifierClass: "swiper-",
	slideClass: "swiper-slide",
	slideBlankClass: "swiper-slide-blank",
	slideActiveClass: "swiper-slide-active",
	slideVisibleClass: "swiper-slide-visible",
	slideFullyVisibleClass: "swiper-slide-fully-visible",
	slideNextClass: "swiper-slide-next",
	slidePrevClass: "swiper-slide-prev",
	wrapperClass: "swiper-wrapper",
	lazyPreloaderClass: "swiper-lazy-preloader",
	lazyPreloadPrevNext: 0,
	runCallbacksOnInit: !0,
	_emitClasses: !1
};
function Zt(i, e) {
	return function(s) {
		s === void 0 && (s = {});
		const n = Object.keys(s)[0]
		  , r = s[n];
		if (typeof r != "object" || r === null) {
			G(e, s);
			return
		}
		if (i[n] === !0 && (i[n] = {
			enabled: !0
		}),
		n === "navigation" && i[n] && i[n].enabled && !i[n].prevEl && !i[n].nextEl && (i[n].auto = !0),
		["pagination", "scrollbar"].indexOf(n) >= 0 && i[n] && i[n].enabled && !i[n].el && (i[n].auto = !0),
		!(n in i && "enabled"in r)) {
			G(e, s);
			return
		}
		typeof i[n] == "object" && !("enabled"in i[n]) && (i[n].enabled = !0),
		i[n] || (i[n] = {
			enabled: !1
		}),
		G(e, s)
	}
}
const ne = {
	eventsEmitter: Ue,
	update: lt,
	translate: pt,
	transition: vt,
	slide: Ct,
	loop: It,
	grabCursor: zt,
	events: Rt,
	breakpoints: jt,
	checkOverflow: Qt,
	classes: Ut
}
  , ae = {};
class B {
	constructor() {
		let e, t;
		for (var s = arguments.length, n = new Array(s), r = 0; r < s; r++)
			n[r] = arguments[r];
		n.length === 1 && n[0].constructor && Object.prototype.toString.call(n[0]).slice(8, -1) === "Object" ? t = n[0] : [e,t] = n,
		t || (t = {}),
		t = G({}, t),
		e && !t.el && (t.el = e);
		const o = _();
		if (t.el && typeof t.el == "string" && o.querySelectorAll(t.el).length > 1) {
			const c = [];
			return o.querySelectorAll(t.el).forEach(p=>{
				const h = G({}, t, {
					el: p
				});
				c.push(new B(h))
			}
			),
			c
		}
		const l = this;
		l.__swiper__ = !0,
		l.support = Pe(),
		l.device = Ye({
			userAgent: t.userAgent
		}),
		l.browser = qe(),
		l.eventsListeners = {},
		l.eventsAnyListeners = [],
		l.modules = [...l.__modules__],
		t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
		const a = {};
		l.modules.forEach(c=>{
			c({
				params: t,
				swiper: l,
				extendParams: Zt(t, a),
				on: l.on.bind(l),
				once: l.once.bind(l),
				off: l.off.bind(l),
				emit: l.emit.bind(l)
			})
		}
		);
		const d = G({}, ve, a);
		return l.params = G({}, d, ae, t),
		l.originalParams = G({}, l.params),
		l.passedParams = G({}, t),
		l.params && l.params.on && Object.keys(l.params.on).forEach(c=>{
			l.on(c, l.params.on[c])
		}
		),
		l.params && l.params.onAny && l.onAny(l.params.onAny),
		Object.assign(l, {
			enabled: l.params.enabled,
			el: e,
			classNames: [],
			slides: [],
			slidesGrid: [],
			snapGrid: [],
			slidesSizesGrid: [],
			isHorizontal() {
				return l.params.direction === "horizontal"
			},
			isVertical() {
				return l.params.direction === "vertical"
			},
			activeIndex: 0,
			realIndex: 0,
			isBeginning: !0,
			isEnd: !1,
			translate: 0,
			previousTranslate: 0,
			progress: 0,
			velocity: 0,
			animating: !1,
			cssOverflowAdjustment() {
				return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
			},
			allowSlideNext: l.params.allowSlideNext,
			allowSlidePrev: l.params.allowSlidePrev,
			touchEventsData: {
				isTouched: void 0,
				isMoved: void 0,
				allowTouchCallbacks: void 0,
				touchStartTime: void 0,
				isScrolling: void 0,
				currentTranslate: void 0,
				startTranslate: void 0,
				allowThresholdMove: void 0,
				focusableElements: l.params.focusableElements,
				lastClickTime: 0,
				clickTimeout: void 0,
				velocities: [],
				allowMomentumBounce: void 0,
				startMoving: void 0,
				pointerId: null,
				touchId: null
			},
			allowClick: !0,
			allowTouchMove: l.params.allowTouchMove,
			touches: {
				startX: 0,
				startY: 0,
				currentX: 0,
				currentY: 0,
				diff: 0
			},
			imagesToLoad: [],
			imagesLoaded: 0
		}),
		l.emit("_swiper"),
		l.params.init && l.init(),
		l
	}
	getDirectionLabel(e) {
		return this.isHorizontal() ? e : {
			width: "height",
			"margin-top": "margin-left",
			"margin-bottom ": "margin-right",
			"margin-left": "margin-top",
			"margin-right": "margin-bottom",
			"padding-left": "padding-top",
			"padding-right": "padding-bottom",
			marginRight: "marginBottom"
		}[e]
	}
	getSlideIndex(e) {
		const {slidesEl: t, params: s} = this
		  , n = F(t, `.${s.slideClass}, swiper-slide`)
		  , r = Z(n[0]);
		return Z(e) - r
	}
	getSlideIndexByData(e) {
		return this.getSlideIndex(this.slides.filter(t=>t.getAttribute("data-swiper-slide-index") * 1 === e)[0])
	}
	recalcSlides() {
		const e = this
		  , {slidesEl: t, params: s} = e;
		e.slides = F(t, `.${s.slideClass}, swiper-slide`)
	}
	enable() {
		const e = this;
		e.enabled || (e.enabled = !0,
		e.params.grabCursor && e.setGrabCursor(),
		e.emit("enable"))
	}
	disable() {
		const e = this;
		e.enabled && (e.enabled = !1,
		e.params.grabCursor && e.unsetGrabCursor(),
		e.emit("disable"))
	}
	setProgress(e, t) {
		const s = this;
		e = Math.min(Math.max(e, 0), 1);
		const n = s.minTranslate()
		  , o = (s.maxTranslate() - n) * e + n;
		s.translateTo(o, typeof t > "u" ? 0 : t),
		s.updateActiveIndex(),
		s.updateSlidesClasses()
	}
	emitContainerClasses() {
		const e = this;
		if (!e.params._emitClasses || !e.el)
			return;
		const t = e.el.className.split(" ").filter(s=>s.indexOf("swiper") === 0 || s.indexOf(e.params.containerModifierClass) === 0);
		e.emit("_containerClasses", t.join(" "))
	}
	getSlideClasses(e) {
		const t = this;
		return t.destroyed ? "" : e.className.split(" ").filter(s=>s.indexOf("swiper-slide") === 0 || s.indexOf(t.params.slideClass) === 0).join(" ")
	}
	emitSlidesClasses() {
		const e = this;
		if (!e.params._emitClasses || !e.el)
			return;
		const t = [];
		e.slides.forEach(s=>{
			const n = e.getSlideClasses(s);
			t.push({
				slideEl: s,
				classNames: n
			}),
			e.emit("_slideClass", s, n)
		}
		),
		e.emit("_slideClasses", t)
	}
	slidesPerViewDynamic(e, t) {
		e === void 0 && (e = "current"),
		t === void 0 && (t = !1);
		const s = this
		  , {params: n, slides: r, slidesGrid: o, slidesSizesGrid: l, size: a, activeIndex: d} = s;
		let c = 1;
		if (typeof n.slidesPerView == "number")
			return n.slidesPerView;
		if (n.centeredSlides) {
			let p = r[d] ? r[d].swiperSlideSize : 0, h;
			for (let m = d + 1; m < r.length; m += 1)
				r[m] && !h && (p += r[m].swiperSlideSize,
				c += 1,
				p > a && (h = !0));
			for (let m = d - 1; m >= 0; m -= 1)
				r[m] && !h && (p += r[m].swiperSlideSize,
				c += 1,
				p > a && (h = !0))
		} else if (e === "current")
			for (let p = d + 1; p < r.length; p += 1)
				(t ? o[p] + l[p] - o[d] < a : o[p] - o[d] < a) && (c += 1);
		else
			for (let p = d - 1; p >= 0; p -= 1)
				o[d] - o[p] < a && (c += 1);
		return c
	}
	update() {
		const e = this;
		if (!e || e.destroyed)
			return;
		const {snapGrid: t, params: s} = e;
		s.breakpoints && e.setBreakpoint(),
		[...e.el.querySelectorAll('[loading="lazy"]')].forEach(o=>{
			o.complete && K(e, o)
		}
		),
		e.updateSize(),
		e.updateSlides(),
		e.updateProgress(),
		e.updateSlidesClasses();
		function n() {
			const o = e.rtlTranslate ? e.translate * -1 : e.translate
			  , l = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate());
			e.setTranslate(l),
			e.updateActiveIndex(),
			e.updateSlidesClasses()
		}
		let r;
		if (s.freeMode && s.freeMode.enabled && !s.cssMode)
			n(),
			s.autoHeight && e.updateAutoHeight();
		else {
			if ((s.slidesPerView === "auto" || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) {
				const o = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides;
				r = e.slideTo(o.length - 1, 0, !1, !0)
			} else
				r = e.slideTo(e.activeIndex, 0, !1, !0);
			r || n()
		}
		s.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
		e.emit("update")
	}
	changeDirection(e, t) {
		t === void 0 && (t = !0);
		const s = this
		  , n = s.params.direction;
		return e || (e = n === "horizontal" ? "vertical" : "horizontal"),
		e === n || e !== "horizontal" && e !== "vertical" || (s.el.classList.remove(`${s.params.containerModifierClass}${n}`),
		s.el.classList.add(`${s.params.containerModifierClass}${e}`),
		s.emitContainerClasses(),
		s.params.direction = e,
		s.slides.forEach(r=>{
			e === "vertical" ? r.style.width = "" : r.style.height = ""
		}
		),
		s.emit("changeDirection"),
		t && s.update()),
		s
	}
	changeLanguageDirection(e) {
		const t = this;
		t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl",
		t.rtlTranslate = t.params.direction === "horizontal" && t.rtl,
		t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
		t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
		t.el.dir = "ltr"),
		t.update())
	}
	mount(e) {
		const t = this;
		if (t.mounted)
			return !0;
		let s = e || t.params.el;
		if (typeof s == "string" && (s = document.querySelector(s)),
		!s)
			return !1;
		s.swiper = t,
		s.parentNode && s.parentNode.host && s.parentNode.host.nodeName === "SWIPER-CONTAINER" && (t.isElement = !0);
		const n = ()=>`.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
		let o = s && s.shadowRoot && s.shadowRoot.querySelector ? s.shadowRoot.querySelector(n()) : F(s, n())[0];
		return !o && t.params.createElements && (o = Q("div", t.params.wrapperClass),
		s.append(o),
		F(s, `.${t.params.slideClass}`).forEach(l=>{
			o.append(l)
		}
		)),
		Object.assign(t, {
			el: s,
			wrapperEl: o,
			slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : o,
			hostEl: t.isElement ? s.parentNode.host : s,
			mounted: !0,
			rtl: s.dir.toLowerCase() === "rtl" || N(s, "direction") === "rtl",
			rtlTranslate: t.params.direction === "horizontal" && (s.dir.toLowerCase() === "rtl" || N(s, "direction") === "rtl"),
			wrongRTL: N(o, "display") === "-webkit-box"
		}),
		!0
	}
	init(e) {
		const t = this;
		if (t.initialized || t.mount(e) === !1)
			return t;
		t.emit("beforeInit"),
		t.params.breakpoints && t.setBreakpoint(),
		t.addClasses(),
		t.updateSize(),
		t.updateSlides(),
		t.params.watchOverflow && t.checkOverflow(),
		t.params.grabCursor && t.enabled && t.setGrabCursor(),
		t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
		t.params.loop && t.loopCreate(),
		t.attachEvents();
		const n = [...t.el.querySelectorAll('[loading="lazy"]')];
		return t.isElement && n.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
		n.forEach(r=>{
			r.complete ? K(t, r) : r.addEventListener("load", o=>{
				K(t, o.target)
			}
			)
		}
		),
		de(t),
		t.initialized = !0,
		de(t),
		t.emit("init"),
		t.emit("afterInit"),
		t
	}
	destroy(e, t) {
		e === void 0 && (e = !0),
		t === void 0 && (t = !0);
		const s = this
		  , {params: n, el: r, wrapperEl: o, slides: l} = s;
		return typeof s.params > "u" || s.destroyed || (s.emit("beforeDestroy"),
		s.initialized = !1,
		s.detachEvents(),
		n.loop && s.loopDestroy(),
		t && (s.removeClasses(),
		r.removeAttribute("style"),
		o.removeAttribute("style"),
		l && l.length && l.forEach(a=>{
			a.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass),
			a.removeAttribute("style"),
			a.removeAttribute("data-swiper-slide-index")
		}
		)),
		s.emit("destroy"),
		Object.keys(s.eventsListeners).forEach(a=>{
			s.off(a)
		}
		),
		e !== !1 && (s.el.swiper = null,
		Ve(s)),
		s.destroyed = !0),
		null
	}
	static extendDefaults(e) {
		G(ae, e)
	}
	static get extendedDefaults() {
		return ae
	}
	static get defaults() {
		return ve
	}
	static installModule(e) {
		B.prototype.__modules__ || (B.prototype.__modules__ = []);
		const t = B.prototype.__modules__;
		typeof e == "function" && t.indexOf(e) < 0 && t.push(e)
	}
	static use(e) {
		return Array.isArray(e) ? (e.forEach(t=>B.installModule(t)),
		B) : (B.installModule(e),
		B)
	}
}
Object.keys(ne).forEach(i=>{
	Object.keys(ne[i]).forEach(e=>{
		B.prototype[e] = ne[i][e]
	}
	)
}
);
B.use([Xe, Ke]);
function ei(i, e, t, s) {
	return i.params.createElements && Object.keys(s).forEach(n=>{
		if (!t[n] && t.auto === !0) {
			let r = F(i.el, `.${s[n]}`)[0];
			r || (r = Q("div", s[n]),
			r.className = s[n],
			i.el.append(r)),
			t[n] = r,
			e[n] = r
		}
	}
	),
	t
}
function W(i) {
	return i === void 0 && (i = ""),
	`.${i.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}
function ti(i) {
	let {swiper: e, extendParams: t, on: s, emit: n} = i;
	const r = "swiper-pagination";
	t({
		pagination: {
			el: null,
			bulletElement: "span",
			clickable: !1,
			hideOnClick: !1,
			renderBullet: null,
			renderProgressbar: null,
			renderFraction: null,
			renderCustom: null,
			progressbarOpposite: !1,
			type: "bullets",
			dynamicBullets: !1,
			dynamicMainBullets: 1,
			formatFractionCurrent: u=>u,
			formatFractionTotal: u=>u,
			bulletClass: `${r}-bullet`,
			bulletActiveClass: `${r}-bullet-active`,
			modifierClass: `${r}-`,
			currentClass: `${r}-current`,
			totalClass: `${r}-total`,
			hiddenClass: `${r}-hidden`,
			progressbarFillClass: `${r}-progressbar-fill`,
			progressbarOppositeClass: `${r}-progressbar-opposite`,
			clickableClass: `${r}-clickable`,
			lockClass: `${r}-lock`,
			horizontalClass: `${r}-horizontal`,
			verticalClass: `${r}-vertical`,
			paginationDisabledClass: `${r}-disabled`
		}
	}),
	e.pagination = {
		el: null,
		bullets: []
	};
	let o, l = 0;
	const a = u=>(Array.isArray(u) ? u : [u]).filter(f=>!!f);
	function d() {
		return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0
	}
	function c(u, f) {
		const {bulletActiveClass: g} = e.params.pagination;
		u && (u = u[`${f === "prev" ? "previous" : "next"}ElementSibling`],
		u && (u.classList.add(`${g}-${f}`),
		u = u[`${f === "prev" ? "previous" : "next"}ElementSibling`],
		u && u.classList.add(`${g}-${f}-${f}`)))
	}
	function p(u) {
		const f = u.target.closest(W(e.params.pagination.bulletClass));
		if (!f)
			return;
		u.preventDefault();
		const g = Z(f) * e.params.slidesPerGroup;
		if (e.params.loop) {
			if (e.realIndex === g)
				return;
			e.slideToLoop(g)
		} else
			e.slideTo(g)
	}
	function h() {
		const u = e.rtl
		  , f = e.params.pagination;
		if (d())
			return;
		let g = e.pagination.el;
		g = a(g);
		let T, C;
		const z = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length
		  , A = e.params.loop ? Math.ceil(z / e.params.slidesPerGroup) : e.snapGrid.length;
		if (e.params.loop ? (C = e.previousRealIndex || 0,
		T = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (T = e.snapIndex,
		C = e.previousSnapIndex) : (C = e.previousIndex || 0,
		T = e.activeIndex || 0),
		f.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
			const L = e.pagination.bullets;
			let y, x, M;
			if (f.dynamicBullets && (o = oe(L[0], e.isHorizontal() ? "width" : "height", !0),
			g.forEach(b=>{
				b.style[e.isHorizontal() ? "width" : "height"] = `${o * (f.dynamicMainBullets + 4)}px`
			}
			),
			f.dynamicMainBullets > 1 && C !== void 0 && (l += T - (C || 0),
			l > f.dynamicMainBullets - 1 ? l = f.dynamicMainBullets - 1 : l < 0 && (l = 0)),
			y = Math.max(T - l, 0),
			x = y + (Math.min(L.length, f.dynamicMainBullets) - 1),
			M = (x + y) / 2),
			L.forEach(b=>{
				const P = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(I=>`${f.bulletActiveClass}${I}`)].map(I=>typeof I == "string" && I.includes(" ") ? I.split(" ") : I).flat();
				b.classList.remove(...P)
			}
			),
			g.length > 1)
				L.forEach(b=>{
					const P = Z(b);
					P === T ? b.classList.add(...f.bulletActiveClass.split(" ")) : e.isElement && b.setAttribute("part", "bullet"),
					f.dynamicBullets && (P >= y && P <= x && b.classList.add(...`${f.bulletActiveClass}-main`.split(" ")),
					P === y && c(b, "prev"),
					P === x && c(b, "next"))
				}
				);
			else {
				const b = L[T];
				if (b && b.classList.add(...f.bulletActiveClass.split(" ")),
				e.isElement && L.forEach((P,I)=>{
					P.setAttribute("part", I === T ? "bullet-active" : "bullet")
				}
				),
				f.dynamicBullets) {
					const P = L[y]
					  , I = L[x];
					for (let D = y; D <= x; D += 1)
						L[D] && L[D].classList.add(...`${f.bulletActiveClass}-main`.split(" "));
					c(P, "prev"),
					c(I, "next")
				}
			}
			if (f.dynamicBullets) {
				const b = Math.min(L.length, f.dynamicMainBullets + 4)
				  , P = (o * b - o) / 2 - M * o
				  , I = u ? "right" : "left";
				L.forEach(D=>{
					D.style[e.isHorizontal() ? I : "top"] = `${P}px`
				}
				)
			}
		}
		g.forEach((L,y)=>{
			if (f.type === "fraction" && (L.querySelectorAll(W(f.currentClass)).forEach(x=>{
				x.textContent = f.formatFractionCurrent(T + 1)
			}
			),
			L.querySelectorAll(W(f.totalClass)).forEach(x=>{
				x.textContent = f.formatFractionTotal(A)
			}
			)),
			f.type === "progressbar") {
				let x;
				f.progressbarOpposite ? x = e.isHorizontal() ? "vertical" : "horizontal" : x = e.isHorizontal() ? "horizontal" : "vertical";
				const M = (T + 1) / A;
				let b = 1
				  , P = 1;
				x === "horizontal" ? b = M : P = M,
				L.querySelectorAll(W(f.progressbarFillClass)).forEach(I=>{
					I.style.transform = `translate3d(0,0,0) scaleX(${b}) scaleY(${P})`,
					I.style.transitionDuration = `${e.params.speed}ms`
				}
				)
			}
			f.type === "custom" && f.renderCustom ? (L.innerHTML = f.renderCustom(e, T + 1, A),
			y === 0 && n("paginationRender", L)) : (y === 0 && n("paginationRender", L),
			n("paginationUpdate", L)),
			e.params.watchOverflow && e.enabled && L.classList[e.isLocked ? "add" : "remove"](f.lockClass)
		}
		)
	}
	function m() {
		const u = e.params.pagination;
		if (d())
			return;
		const f = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
		let g = e.pagination.el;
		g = a(g);
		let T = "";
		if (u.type === "bullets") {
			let C = e.params.loop ? Math.ceil(f / e.params.slidesPerGroup) : e.snapGrid.length;
			e.params.freeMode && e.params.freeMode.enabled && C > f && (C = f);
			for (let z = 0; z < C; z += 1)
				u.renderBullet ? T += u.renderBullet.call(e, z, u.bulletClass) : T += `<${u.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${u.bulletClass}"></${u.bulletElement}>`
		}
		u.type === "fraction" && (u.renderFraction ? T = u.renderFraction.call(e, u.currentClass, u.totalClass) : T = `<span class="${u.currentClass}"></span> / <span class="${u.totalClass}"></span>`),
		u.type === "progressbar" && (u.renderProgressbar ? T = u.renderProgressbar.call(e, u.progressbarFillClass) : T = `<span class="${u.progressbarFillClass}"></span>`),
		e.pagination.bullets = [],
		g.forEach(C=>{
			u.type !== "custom" && (C.innerHTML = T || ""),
			u.type === "bullets" && e.pagination.bullets.push(...C.querySelectorAll(W(u.bulletClass)))
		}
		),
		u.type !== "custom" && n("paginationRender", g[0])
	}
	function v() {
		e.params.pagination = ei(e, e.originalParams.pagination, e.params.pagination, {
			el: "swiper-pagination"
		});
		const u = e.params.pagination;
		if (!u.el)
			return;
		let f;
		typeof u.el == "string" && e.isElement && (f = e.el.querySelector(u.el)),
		!f && typeof u.el == "string" && (f = [...document.querySelectorAll(u.el)]),
		f || (f = u.el),
		!(!f || f.length === 0) && (e.params.uniqueNavElements && typeof u.el == "string" && Array.isArray(f) && f.length > 1 && (f = [...e.el.querySelectorAll(u.el)],
		f.length > 1 && (f = f.filter(g=>Me(g, ".swiper")[0] === e.el)[0])),
		Array.isArray(f) && f.length === 1 && (f = f[0]),
		Object.assign(e.pagination, {
			el: f
		}),
		f = a(f),
		f.forEach(g=>{
			u.type === "bullets" && u.clickable && g.classList.add(...(u.clickableClass || "").split(" ")),
			g.classList.add(u.modifierClass + u.type),
			g.classList.add(e.isHorizontal() ? u.horizontalClass : u.verticalClass),
			u.type === "bullets" && u.dynamicBullets && (g.classList.add(`${u.modifierClass}${u.type}-dynamic`),
			l = 0,
			u.dynamicMainBullets < 1 && (u.dynamicMainBullets = 1)),
			u.type === "progressbar" && u.progressbarOpposite && g.classList.add(u.progressbarOppositeClass),
			u.clickable && g.addEventListener("click", p),
			e.enabled || g.classList.add(u.lockClass)
		}
		))
	}
	function S() {
		const u = e.params.pagination;
		if (d())
			return;
		let f = e.pagination.el;
		f && (f = a(f),
		f.forEach(g=>{
			g.classList.remove(u.hiddenClass),
			g.classList.remove(u.modifierClass + u.type),
			g.classList.remove(e.isHorizontal() ? u.horizontalClass : u.verticalClass),
			u.clickable && (g.classList.remove(...(u.clickableClass || "").split(" ")),
			g.removeEventListener("click", p))
		}
		)),
		e.pagination.bullets && e.pagination.bullets.forEach(g=>g.classList.remove(...u.bulletActiveClass.split(" ")))
	}
	s("changeDirection", ()=>{
		if (!e.pagination || !e.pagination.el)
			return;
		const u = e.params.pagination;
		let {el: f} = e.pagination;
		f = a(f),
		f.forEach(g=>{
			g.classList.remove(u.horizontalClass, u.verticalClass),
			g.classList.add(e.isHorizontal() ? u.horizontalClass : u.verticalClass)
		}
		)
	}
	),
	s("init", ()=>{
		e.params.pagination.enabled === !1 ? w() : (v(),
		m(),
		h())
	}
	),
	s("activeIndexChange", ()=>{
		typeof e.snapIndex > "u" && h()
	}
	),
	s("snapIndexChange", ()=>{
		h()
	}
	),
	s("snapGridLengthChange", ()=>{
		m(),
		h()
	}
	),
	s("destroy", ()=>{
		S()
	}
	),
	s("enable disable", ()=>{
		let {el: u} = e.pagination;
		u && (u = a(u),
		u.forEach(f=>f.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)))
	}
	),
	s("lock unlock", ()=>{
		h()
	}
	),
	s("click", (u,f)=>{
		const g = f.target
		  , T = a(e.pagination.el);
		if (e.params.pagination.el && e.params.pagination.hideOnClick && T && T.length > 0 && !g.classList.contains(e.params.pagination.bulletClass)) {
			if (e.navigation && (e.navigation.nextEl && g === e.navigation.nextEl || e.navigation.prevEl && g === e.navigation.prevEl))
				return;
			const C = T[0].classList.contains(e.params.pagination.hiddenClass);
			n(C === !0 ? "paginationShow" : "paginationHide"),
			T.forEach(z=>z.classList.toggle(e.params.pagination.hiddenClass))
		}
	}
	);
	const E = ()=>{
		e.el.classList.remove(e.params.pagination.paginationDisabledClass);
		let {el: u} = e.pagination;
		u && (u = a(u),
		u.forEach(f=>f.classList.remove(e.params.pagination.paginationDisabledClass))),
		v(),
		m(),
		h()
	}
	  , w = ()=>{
		e.el.classList.add(e.params.pagination.paginationDisabledClass);
		let {el: u} = e.pagination;
		u && (u = a(u),
		u.forEach(f=>f.classList.add(e.params.pagination.paginationDisabledClass))),
		S()
	}
	;
	Object.assign(e.pagination, {
		enable: E,
		disable: w,
		render: m,
		update: h,
		init: v,
		destroy: S
	})
}
function ii(i) {
	let {swiper: e, extendParams: t, on: s, emit: n, params: r} = i;
	e.autoplay = {
		running: !1,
		paused: !1,
		timeLeft: 0
	},
	t({
		autoplay: {
			enabled: !1,
			delay: 3e3,
			waitForTransition: !0,
			disableOnInteraction: !1,
			stopOnLastSlide: !1,
			reverseDirection: !1,
			pauseOnMouseEnter: !1
		}
	});
	let o, l, a = r && r.autoplay ? r.autoplay.delay : 3e3, d = r && r.autoplay ? r.autoplay.delay : 3e3, c, p = new Date().getTime(), h, m, v, S, E, w, u;
	function f(O) {
		!e || e.destroyed || !e.wrapperEl || O.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", f),
		!u && y())
	}
	const g = ()=>{
		if (e.destroyed || !e.autoplay.running)
			return;
		e.autoplay.paused ? h = !0 : h && (d = c,
		h = !1);
		const O = e.autoplay.paused ? c : p + d - new Date().getTime();
		e.autoplay.timeLeft = O,
		n("autoplayTimeLeft", O, O / a),
		l = requestAnimationFrame(()=>{
			g()
		}
		)
	}
	  , T = ()=>{
		let O;
		return e.virtual && e.params.virtual.enabled ? O = e.slides.filter(k=>k.classList.contains("swiper-slide-active"))[0] : O = e.slides[e.activeIndex],
		O ? parseInt(O.getAttribute("data-swiper-autoplay"), 10) : void 0
	}
	  , C = O=>{
		if (e.destroyed || !e.autoplay.running)
			return;
		cancelAnimationFrame(l),
		g();
		let V = typeof O > "u" ? e.params.autoplay.delay : O;
		a = e.params.autoplay.delay,
		d = e.params.autoplay.delay;
		const k = T();
		!Number.isNaN(k) && k > 0 && typeof O > "u" && (V = k,
		a = k,
		d = k),
		c = V;
		const H = e.params.speed
		  , Y = ()=>{
			!e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(H, !0, !0),
			n("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, H, !0, !0),
			n("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(H, !0, !0),
			n("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, H, !0, !0),
			n("autoplay")),
			e.params.cssMode && (p = new Date().getTime(),
			requestAnimationFrame(()=>{
				C()
			}
			)))
		}
		;
		return V > 0 ? (clearTimeout(o),
		o = setTimeout(()=>{
			Y()
		}
		, V)) : requestAnimationFrame(()=>{
			Y()
		}
		),
		V
	}
	  , z = ()=>{
		p = new Date().getTime(),
		e.autoplay.running = !0,
		C(),
		n("autoplayStart")
	}
	  , A = ()=>{
		e.autoplay.running = !1,
		clearTimeout(o),
		cancelAnimationFrame(l),
		n("autoplayStop")
	}
	  , L = (O,V)=>{
		if (e.destroyed || !e.autoplay.running)
			return;
		clearTimeout(o),
		O || (w = !0);
		const k = ()=>{
			n("autoplayPause"),
			e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", f) : y()
		}
		;
		if (e.autoplay.paused = !0,
		V) {
			E && (c = e.params.autoplay.delay),
			E = !1,
			k();
			return
		}
		c = (c || e.params.autoplay.delay) - (new Date().getTime() - p),
		!(e.isEnd && c < 0 && !e.params.loop) && (c < 0 && (c = 0),
		k())
	}
	  , y = ()=>{
		e.isEnd && c < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (p = new Date().getTime(),
		w ? (w = !1,
		C(c)) : C(),
		e.autoplay.paused = !1,
		n("autoplayResume"))
	}
	  , x = ()=>{
		if (e.destroyed || !e.autoplay.running)
			return;
		const O = _();
		O.visibilityState === "hidden" && (w = !0,
		L(!0)),
		O.visibilityState === "visible" && y()
	}
	  , M = O=>{
		O.pointerType === "mouse" && (w = !0,
		u = !0,
		!(e.animating || e.autoplay.paused) && L(!0))
	}
	  , b = O=>{
		O.pointerType === "mouse" && (u = !1,
		e.autoplay.paused && y())
	}
	  , P = ()=>{
		e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", M),
		e.el.addEventListener("pointerleave", b))
	}
	  , I = ()=>{
		e.el.removeEventListener("pointerenter", M),
		e.el.removeEventListener("pointerleave", b)
	}
	  , D = ()=>{
		_().addEventListener("visibilitychange", x)
	}
	  , ee = ()=>{
		_().removeEventListener("visibilitychange", x)
	}
	;
	s("init", ()=>{
		e.params.autoplay.enabled && (P(),
		D(),
		z())
	}
	),
	s("destroy", ()=>{
		I(),
		ee(),
		e.autoplay.running && A()
	}
	),
	s("_freeModeStaticRelease", ()=>{
		(v || w) && y()
	}
	),
	s("_freeModeNoMomentumRelease", ()=>{
		e.params.autoplay.disableOnInteraction ? A() : L(!0, !0)
	}
	),
	s("beforeTransitionStart", (O,V,k)=>{
		e.destroyed || !e.autoplay.running || (k || !e.params.autoplay.disableOnInteraction ? L(!0, !0) : A())
	}
	),
	s("sliderFirstMove", ()=>{
		if (!(e.destroyed || !e.autoplay.running)) {
			if (e.params.autoplay.disableOnInteraction) {
				A();
				return
			}
			m = !0,
			v = !1,
			w = !1,
			S = setTimeout(()=>{
				w = !0,
				v = !0,
				L(!0)
			}
			, 200)
		}
	}
	),
	s("touchEnd", ()=>{
		if (!(e.destroyed || !e.autoplay.running || !m)) {
			if (clearTimeout(S),
			clearTimeout(o),
			e.params.autoplay.disableOnInteraction) {
				v = !1,
				m = !1;
				return
			}
			v && e.params.cssMode && y(),
			v = !1,
			m = !1
		}
	}
	),
	s("slideChange", ()=>{
		e.destroyed || !e.autoplay.running || (E = !0)
	}
	),
	Object.assign(e.autoplay, {
		start: z,
		stop: A,
		pause: L,
		resume: y
	})
}
var ce = {
	exports: {}
};
(function(i, e) {
	(function(t, s) {
		s(e)
	}
	)(De, function(t) {
		var s = function() {
			return s = Object.assign || function(l) {
				for (var a, d = 1, c = arguments.length; d < c; d++) {
					a = arguments[d];
					for (var p in a)
						Object.prototype.hasOwnProperty.call(a, p) && (l[p] = a[p])
				}
				return l
			}
			,
			s.apply(this, arguments)
		};
		typeof SuppressedError == "function" && SuppressedError,
		t.TouchSwipeEventType = void 0,
		function(o) {
			o.up = "swipeup",
			o.tap = "tap",
			o.down = "swipedown",
			o.move = "swipemove",
			o.left = "swipeleft",
			o.right = "swiperight"
		}(t.TouchSwipeEventType || (t.TouchSwipeEventType = {}));
		var n = {
			endX: 0,
			endY: 0,
			moveX: 0,
			moveY: 0,
			startX: 0,
			startY: 0
		}
		  , r = function() {
			function o(l, a, d) {
				return l === void 0 && (l = document.body),
				a === void 0 && (a = {}),
				d === void 0 && (d = 40),
				this.element = l,
				this.eventData = a,
				this.threshold = d,
				this.coords = n,
				this.isMoving = !1,
				this.moveCoords = {
					x: 0,
					y: 0
				},
				this.onStart = this.onStart.bind(this),
				this.onMove = this.onMove.bind(this),
				this.onEnd = this.onEnd.bind(this),
				this.bind(),
				this
			}
			return o.prototype.bind = function() {
				var l = this.element;
				l.addEventListener("touchstart", this.onStart, {
					passive: !0
				}),
				l.addEventListener("touchmove", this.onMove, {
					passive: !0
				}),
				l.addEventListener("touchend", this.onEnd, {
					passive: !0
				}),
				l.addEventListener("mousedown", this.onStart, {
					passive: !0
				}),
				l.addEventListener("mousemove", this.onMove, {
					passive: !0
				}),
				l.addEventListener("mouseup", this.onEnd, {
					passive: !0
				})
			}
			,
			o.prototype.unbind = function() {
				var l = this.element;
				l.removeEventListener("touchstart", this.onStart, !1),
				l.removeEventListener("touchmove", this.onMove, !1),
				l.removeEventListener("touchend", this.onEnd, !1),
				l.removeEventListener("mousedown", this.onStart, !1),
				l.removeEventListener("mousemove", this.onMove, !1),
				l.removeEventListener("mouseup", this.onEnd, !1)
			}
			,
			o.prototype.getCoords = function(l) {
				var a = this.moveCoords
				  , d = "pageX"in l;
				return a.x = d ? l.pageX : l.changedTouches[0].screenX,
				a.y = d ? l.pageY : l.changedTouches[0].screenY,
				a
			}
			,
			o.prototype.resetCoords = function() {
				this.coords = n
			}
			,
			o.prototype.getEndEventName = function() {
				var l = this.threshold
				  , a = this.coords
				  , d = a.startX
				  , c = a.startY
				  , p = a.endX
				  , h = a.endY
				  , m = Math.abs(p - d)
				  , v = Math.abs(h - c)
				  , S = m > v;
				if (S) {
					if (p < d && m > l)
						return t.TouchSwipeEventType.left;
					if (p > d && m > l)
						return t.TouchSwipeEventType.right
				} else {
					if (h < c && v > l)
						return t.TouchSwipeEventType.up;
					if (h > c && v > l)
						return t.TouchSwipeEventType.down
				}
				return h === c && p === d ? t.TouchSwipeEventType.tap : ""
			}
			,
			o.prototype.dispatchEvent = function(l) {
				var a = new CustomEvent(l,{
					detail: s(s({}, this.eventData), {
						coords: this.coords
					})
				});
				this.element.dispatchEvent(a)
			}
			,
			o.prototype.dispatchEnd = function() {
				var l = this.getEndEventName();
				l && this.dispatchEvent(l)
			}
			,
			o.prototype.onStart = function(l) {
				var a = this.getCoords(l)
				  , d = a.x
				  , c = a.y;
				this.isMoving = !0,
				this.coords.startX = d,
				this.coords.startY = c
			}
			,
			o.prototype.onMove = function(l) {
				if (this.isMoving) {
					var a = this.getCoords(l)
					  , d = a.x
					  , c = a.y;
					this.coords.moveX = d,
					this.coords.moveY = c,
					this.dispatchEvent(t.TouchSwipeEventType.move)
				}
			}
			,
			o.prototype.onEnd = function(l) {
				var a = this.getCoords(l)
				  , d = a.x
				  , c = a.y;
				this.isMoving = !1,
				this.coords.endX = d,
				this.coords.endY = c,
				this.dispatchEnd(),
				this.resetCoords()
			}
			,
			o
		}();
		t.default = r,
		Object.defineProperty(t, "__esModule", {
			value: !0
		})
	})
}
)(ce, ce.exports);
var si = ce.exports;
const ri = ke(si);
function ni(i, e) {
	let t;
	return function(...s) {
		clearTimeout(t),
		t = setTimeout(()=>{
			i.apply(this, s)
		}
		, e)
	}
}
const R = document.querySelector(".swiper")
  , we = document.querySelector(".form--welcome")
  , ai = document.querySelector(".header")
  , ye = document.querySelector(".swiper-pagination")
  , Se = document.querySelectorAll(".slide__info")
  , li = document.querySelector(".gradient")
  , Te = function() {
	this.slidePrev(),
	setTimeout(()=>{
		window.matchMedia("(orientation: landscape)").matches ? (R.style.width = `${document.body.offsetWidth - 450}px`,
		R.style.height = `${window.innerHeight - ai?.offsetHeight || 0}px`) : (R.style.width = "100%",
		R.style.height = "100%")
	}
	, 100),
	window.matchMedia("(orientation: landscape)").matches ? (ye.style.bottom = "",
	Se.forEach(i=>{
		i.style.bottom = ""
	}
	)) : (ye.style.bottom = `${we.offsetHeight + 50}px`,
	Se.forEach(i=>{
		i.style.bottom = `${we.offsetHeight + 70}px`
	}
	)),
	setTimeout(()=>{
		R.style.opacity = "1"
	}
	, 200)
}
  , ue = new B(R,{
	modules: [ti, ii],
	loop: !0,
	loopPreventsSliding: !1,
	autoplay: {
		delay: 3e3
	},
	speed: 500,
	mousewheel: !1,
	allowTouchMove: !1,
	centeredSlides: !0,
	pagination: {
		el: ".swiper-pagination",
		clickable: !0
	},
	on: {
		beforeInit: Te,
		update: Te,
		slideChange: i=>{
			const e = `${i.slides[i.activeIndex]?.dataset.bg}`;
			li.style.background = e || ""
		}
	},
	breakpoints: {
		320: {
			slidesPerView: "auto"
		},
		1200: {
			slidesPerView: 3
		}
	}
})
  , oi = ni(()=>{
	ue.update()
}
, 250);
window.addEventListener("resize", oi);
const X = document.querySelector(".action");
X && (new ri(X,{
	value: 1
},20),
X.addEventListener("swipeleft", i=>{
	ue.slideNext()
}
),
X.addEventListener("swiperight", i=>{
	ue.slidePrev()
}
));
xe();
const be = document.querySelector("#button-primary");
be && ze.clickContinueWithEmail().then(i=>{
	be.addEventListener("click", ()=>{
		i()
	}
	)
}
);
xe();

import {g as r, d as i, b as t} from "./Cookie.astro_astro_type_script_index_0_lang.WHDXDktG.js";
import {r as l} from "./redirect.wOMpoOAS.js";
const a = e=>{
	e && e.credential ? window.googleSignIn(e.credential).then(async()=>{
		await i("google"),
		l()
	}
	).catch(async n=>{
		[403, 401].includes(n?.response?.status) ? (localStorage.setItem("googleCredential", JSON.stringify(e.credential)),
		window.location.href = "/google") : await t.errorGoogleSignIn(`Unknown error. Response status code: ${n?.response?.status}`)
	}
	) : t.errorGoogleSignIn("Google SignIn: no credentials returned from google")
}
;
window.redirect = l;
window.googleSignIn = r;
window.annalsSignIn = i;
window.handleCredentialResponse = a;
document.addEventListener("DOMContentLoaded", ()=>{
	const e = document.getElementById("button-google")
	  , n = document.querySelector(".g_id_signin div[role=button]")
	  , o = ()=>{
		t.clickSignInGoogle(),
		e?.removeEventListener("click", o)
	}
	;
	e?.addEventListener("click", o),
	e && n && e.addEventListener("click", ()=>{
		n.click()
	}
	)
}
);

function __vite__mapDeps(indexes) {
	if (!__vite__mapDeps.viteFileDeps) {
		__vite__mapDeps.viteFileDeps = ["_astro/markers.knhZWxmI.js", "_astro/base.Dp3-MWEb.js"]
	}
	return indexes.map((i)=>__vite__mapDeps.viteFileDeps[i])
}
const ot = "modulepreload"
  , st = function(e) {
	return "/" + e
}
  , we = {}
  , it = function(t, n, r) {
	let o = Promise.resolve();
	if (n && n.length > 0) {
		const i = document.getElementsByTagName("link")
		  , s = document.querySelector("meta[property=csp-nonce]")
		  , c = s?.nonce || s?.getAttribute("nonce");
		o = Promise.all(n.map(u=>{
			if (u = st(u),
			u in we)
				return;
			we[u] = !0;
			const d = u.endsWith(".css")
			  , f = d ? '[rel="stylesheet"]' : "";
			if (!!r)
				for (let g = i.length - 1; g >= 0; g--) {
					const p = i[g];
					if (p.href === u && (!d || p.rel === "stylesheet"))
						return
				}
			else if (document.querySelector(`link[href="${u}"]${f}`))
				return;
			const y = document.createElement("link");
			if (y.rel = d ? "stylesheet" : ot,
			d || (y.as = "script",
			y.crossOrigin = ""),
			y.href = u,
			c && y.setAttribute("nonce", c),
			document.head.appendChild(y),
			d)
				return new Promise((g,p)=>{
					y.addEventListener("load", g),
					y.addEventListener("error", ()=>p(new Error(`Unable to preload CSS for ${u}`)))
				}
				)
		}
		))
	}
	return o.then(()=>t()).catch(i=>{
		const s = new Event("vite:preloadError",{
			cancelable: !0
		});
		if (s.payload = i,
		window.dispatchEvent(s),
		!s.defaultPrevented)
			throw i
	}
	)
};
function _e(e, t) {
	return function() {
		return e.apply(t, arguments)
	}
}
const {toString: at} = Object.prototype
  , {getPrototypeOf: fe} = Object
  , W = (e=>t=>{
	const n = at.call(t);
	return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , C = e=>(e = e.toLowerCase(),
t=>W(t) === e)
  , K = e=>t=>typeof t === e
  , {isArray: D} = Array
  , q = K("undefined");
function ct(e) {
	return e !== null && !q(e) && e.constructor !== null && !q(e.constructor) && T(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const Ue = C("ArrayBuffer");
function lt(e) {
	let t;
	return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Ue(e.buffer),
	t
}
const ut = K("string")
  , T = K("function")
  , Fe = K("number")
  , G = e=>e !== null && typeof e == "object"
  , ft = e=>e === !0 || e === !1
  , z = e=>{
	if (W(e) !== "object")
		return !1;
	const t = fe(e);
	return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
  , dt = C("Date")
  , pt = C("File")
  , ht = C("Blob")
  , mt = C("FileList")
  , yt = e=>G(e) && T(e.pipe)
  , wt = e=>{
	let t;
	return e && (typeof FormData == "function" && e instanceof FormData || T(e.append) && ((t = W(e)) === "formdata" || t === "object" && T(e.toString) && e.toString() === "[object FormData]"))
}
  , gt = C("URLSearchParams")
  , bt = e=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function $(e, t, {allOwnKeys: n=!1}={}) {
	if (e === null || typeof e > "u")
		return;
	let r, o;
	if (typeof e != "object" && (e = [e]),
	D(e))
		for (r = 0,
		o = e.length; r < o; r++)
			t.call(null, e[r], r, e);
	else {
		const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
		  , s = i.length;
		let c;
		for (r = 0; r < s; r++)
			c = i[r],
			t.call(null, e[c], c, e)
	}
}
function Le(e, t) {
	t = t.toLowerCase();
	const n = Object.keys(e);
	let r = n.length, o;
	for (; r-- > 0; )
		if (o = n[r],
		t === o.toLowerCase())
			return o;
	return null
}
const Be = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global
  , De = e=>!q(e) && e !== Be;
function se() {
	const {caseless: e} = De(this) && this || {}
	  , t = {}
	  , n = (r,o)=>{
		const i = e && Le(t, o) || o;
		z(t[i]) && z(r) ? t[i] = se(t[i], r) : z(r) ? t[i] = se({}, r) : D(r) ? t[i] = r.slice() : t[i] = r
	}
	;
	for (let r = 0, o = arguments.length; r < o; r++)
		arguments[r] && $(arguments[r], n);
	return t
}
const Et = (e,t,n,{allOwnKeys: r}={})=>($(t, (o,i)=>{
	n && T(o) ? e[i] = _e(o, n) : e[i] = o
}
, {
	allOwnKeys: r
}),
e)
  , St = e=>(e.charCodeAt(0) === 65279 && (e = e.slice(1)),
e)
  , Rt = (e,t,n,r)=>{
	e.prototype = Object.create(t.prototype, r),
	e.prototype.constructor = e,
	Object.defineProperty(e, "super", {
		value: t.prototype
	}),
	n && Object.assign(e.prototype, n)
}
  , At = (e,t,n,r)=>{
	let o, i, s;
	const c = {};
	if (t = t || {},
	e == null)
		return t;
	do {
		for (o = Object.getOwnPropertyNames(e),
		i = o.length; i-- > 0; )
			s = o[i],
			(!r || r(s, e, t)) && !c[s] && (t[s] = e[s],
			c[s] = !0);
		e = n !== !1 && fe(e)
	} while (e && (!n || n(e, t)) && e !== Object.prototype);
	return t
}
  , Ot = (e,t,n)=>{
	e = String(e),
	(n === void 0 || n > e.length) && (n = e.length),
	n -= t.length;
	const r = e.indexOf(t, n);
	return r !== -1 && r === n
}
  , Tt = e=>{
	if (!e)
		return null;
	if (D(e))
		return e;
	let t = e.length;
	if (!Fe(t))
		return null;
	const n = new Array(t);
	for (; t-- > 0; )
		n[t] = e[t];
	return n
}
  , Pt = (e=>t=>e && t instanceof e)(typeof Uint8Array < "u" && fe(Uint8Array))
  , xt = (e,t)=>{
	const r = (e && e[Symbol.iterator]).call(e);
	let o;
	for (; (o = r.next()) && !o.done; ) {
		const i = o.value;
		t.call(e, i[0], i[1])
	}
}
  , Nt = (e,t)=>{
	let n;
	const r = [];
	for (; (n = e.exec(t)) !== null; )
		r.push(n);
	return r
}
  , Ct = C("HTMLFormElement")
  , kt = e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, o) {
	return r.toUpperCase() + o
})
  , ge = (({hasOwnProperty: e})=>(t,n)=>e.call(t, n))(Object.prototype)
  , _t = C("RegExp")
  , Ie = (e,t)=>{
	const n = Object.getOwnPropertyDescriptors(e)
	  , r = {};
	$(n, (o,i)=>{
		let s;
		(s = t(o, i, e)) !== !1 && (r[i] = s || o)
	}
	),
	Object.defineProperties(e, r)
}
  , Ut = e=>{
	Ie(e, (t,n)=>{
		if (T(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
			return !1;
		const r = e[n];
		if (T(r)) {
			if (t.enumerable = !1,
			"writable"in t) {
				t.writable = !1;
				return
			}
			t.set || (t.set = ()=>{
				throw Error("Can not rewrite read-only method '" + n + "'")
			}
			)
		}
	}
	)
}
  , Ft = (e,t)=>{
	const n = {}
	  , r = o=>{
		o.forEach(i=>{
			n[i] = !0
		}
		)
	}
	;
	return D(e) ? r(e) : r(String(e).split(t)),
	n
}
  , Lt = ()=>{}
  , Bt = (e,t)=>(e = +e,
Number.isFinite(e) ? e : t)
  , ee = "abcdefghijklmnopqrstuvwxyz"
  , be = "0123456789"
  , je = {
	DIGIT: be,
	ALPHA: ee,
	ALPHA_DIGIT: ee + ee.toUpperCase() + be
}
  , Dt = (e=16,t=je.ALPHA_DIGIT)=>{
	let n = "";
	const {length: r} = t;
	for (; e--; )
		n += t[Math.random() * r | 0];
	return n
}
;
function It(e) {
	return !!(e && T(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator])
}
const jt = e=>{
	const t = new Array(10)
	  , n = (r,o)=>{
		if (G(r)) {
			if (t.indexOf(r) >= 0)
				return;
			if (!("toJSON"in r)) {
				t[o] = r;
				const i = D(r) ? [] : {};
				return $(r, (s,c)=>{
					const u = n(s, o + 1);
					!q(u) && (i[c] = u)
				}
				),
				t[o] = void 0,
				i
			}
		}
		return r
	}
	;
	return n(e, 0)
}
  , qt = C("AsyncFunction")
  , $t = e=>e && (G(e) || T(e)) && T(e.then) && T(e.catch)
  , a = {
	isArray: D,
	isArrayBuffer: Ue,
	isBuffer: ct,
	isFormData: wt,
	isArrayBufferView: lt,
	isString: ut,
	isNumber: Fe,
	isBoolean: ft,
	isObject: G,
	isPlainObject: z,
	isUndefined: q,
	isDate: dt,
	isFile: pt,
	isBlob: ht,
	isRegExp: _t,
	isFunction: T,
	isStream: yt,
	isURLSearchParams: gt,
	isTypedArray: Pt,
	isFileList: mt,
	forEach: $,
	merge: se,
	extend: Et,
	trim: bt,
	stripBOM: St,
	inherits: Rt,
	toFlatObject: At,
	kindOf: W,
	kindOfTest: C,
	endsWith: Ot,
	toArray: Tt,
	forEachEntry: xt,
	matchAll: Nt,
	isHTMLForm: Ct,
	hasOwnProperty: ge,
	hasOwnProp: ge,
	reduceDescriptors: Ie,
	freezeMethods: Ut,
	toObjectSet: Ft,
	toCamelCase: kt,
	noop: Lt,
	toFiniteNumber: Bt,
	findKey: Le,
	global: Be,
	isContextDefined: De,
	ALPHABET: je,
	generateString: Dt,
	isSpecCompliantForm: It,
	toJSONObject: jt,
	isAsyncFn: qt,
	isThenable: $t
};
function m(e, t, n, r, o) {
	Error.call(this),
	Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
	this.message = e,
	this.name = "AxiosError",
	t && (this.code = t),
	n && (this.config = n),
	r && (this.request = r),
	o && (this.response = o)
}
a.inherits(m, Error, {
	toJSON: function() {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: a.toJSONObject(this.config),
			code: this.code,
			status: this.response && this.response.status ? this.response.status : null
		}
	}
});
const qe = m.prototype
  , $e = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e=>{
	$e[e] = {
		value: e
	}
}
);
Object.defineProperties(m, $e);
Object.defineProperty(qe, "isAxiosError", {
	value: !0
});
m.from = (e,t,n,r,o,i)=>{
	const s = Object.create(qe);
	return a.toFlatObject(e, s, function(u) {
		return u !== Error.prototype
	}, c=>c !== "isAxiosError"),
	m.call(s, e.message, t, n, r, o),
	s.cause = e,
	s.name = e.name,
	i && Object.assign(s, i),
	s
}
;
const Ht = null;
function ie(e) {
	return a.isPlainObject(e) || a.isArray(e)
}
function He(e) {
	return a.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function Ee(e, t, n) {
	return e ? e.concat(t).map(function(o, i) {
		return o = He(o),
		!n && i ? "[" + o + "]" : o
	}).join(n ? "." : "") : t
}
function vt(e) {
	return a.isArray(e) && !e.some(ie)
}
const zt = a.toFlatObject(a, {}, null, function(t) {
	return /^is[A-Z]/.test(t)
});
function X(e, t, n) {
	if (!a.isObject(e))
		throw new TypeError("target must be an object");
	t = t || new FormData,
	n = a.toFlatObject(n, {
		metaTokens: !0,
		dots: !1,
		indexes: !1
	}, !1, function(h, E) {
		return !a.isUndefined(E[h])
	});
	const r = n.metaTokens
	  , o = n.visitor || f
	  , i = n.dots
	  , s = n.indexes
	  , u = (n.Blob || typeof Blob < "u" && Blob) && a.isSpecCompliantForm(t);
	if (!a.isFunction(o))
		throw new TypeError("visitor must be a function");
	function d(p) {
		if (p === null)
			return "";
		if (a.isDate(p))
			return p.toISOString();
		if (!u && a.isBlob(p))
			throw new m("Blob is not supported. Use a Buffer instead.");
		return a.isArrayBuffer(p) || a.isTypedArray(p) ? u && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p
	}
	function f(p, h, E) {
		let R = p;
		if (p && !E && typeof p == "object") {
			if (a.endsWith(h, "{}"))
				h = r ? h : h.slice(0, -2),
				p = JSON.stringify(p);
			else if (a.isArray(p) && vt(p) || (a.isFileList(p) || a.endsWith(h, "[]")) && (R = a.toArray(p)))
				return h = He(h),
				R.forEach(function(F, rt) {
					!(a.isUndefined(F) || F === null) && t.append(s === !0 ? Ee([h], rt, i) : s === null ? h : h + "[]", d(F))
				}),
				!1
		}
		return ie(p) ? !0 : (t.append(Ee(E, h, i), d(p)),
		!1)
	}
	const l = []
	  , y = Object.assign(zt, {
		defaultVisitor: f,
		convertValue: d,
		isVisitable: ie
	});
	function g(p, h) {
		if (!a.isUndefined(p)) {
			if (l.indexOf(p) !== -1)
				throw Error("Circular reference detected in " + h.join("."));
			l.push(p),
			a.forEach(p, function(R, U) {
				(!(a.isUndefined(R) || R === null) && o.call(t, R, a.isString(U) ? U.trim() : U, h, y)) === !0 && g(R, h ? h.concat(U) : [U])
			}),
			l.pop()
		}
	}
	if (!a.isObject(e))
		throw new TypeError("data must be an object");
	return g(e),
	t
}
function Se(e) {
	const t = {
		"!": "%21",
		"'": "%27",
		"(": "%28",
		")": "%29",
		"~": "%7E",
		"%20": "+",
		"%00": "\0"
	};
	return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
		return t[r]
	})
}
function de(e, t) {
	this._pairs = [],
	e && X(e, this, t)
}
const ve = de.prototype;
ve.append = function(t, n) {
	this._pairs.push([t, n])
}
;
ve.toString = function(t) {
	const n = t ? function(r) {
		return t.call(this, r, Se)
	}
	: Se;
	return this._pairs.map(function(o) {
		return n(o[0]) + "=" + n(o[1])
	}, "").join("&")
}
;
function Mt(e) {
	return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function ze(e, t, n) {
	if (!t)
		return e;
	const r = n && n.encode || Mt
	  , o = n && n.serialize;
	let i;
	if (o ? i = o(t, n) : i = a.isURLSearchParams(t) ? t.toString() : new de(t,n).toString(r),
	i) {
		const s = e.indexOf("#");
		s !== -1 && (e = e.slice(0, s)),
		e += (e.indexOf("?") === -1 ? "?" : "&") + i
	}
	return e
}
class Re {
	constructor() {
		this.handlers = []
	}
	use(t, n, r) {
		return this.handlers.push({
			fulfilled: t,
			rejected: n,
			synchronous: r ? r.synchronous : !1,
			runWhen: r ? r.runWhen : null
		}),
		this.handlers.length - 1
	}
	eject(t) {
		this.handlers[t] && (this.handlers[t] = null)
	}
	clear() {
		this.handlers && (this.handlers = [])
	}
	forEach(t) {
		a.forEach(this.handlers, function(r) {
			r !== null && t(r)
		})
	}
}
const Me = {
	silentJSONParsing: !0,
	forcedJSONParsing: !0,
	clarifyTimeoutError: !1
}
  , Jt = typeof URLSearchParams < "u" ? URLSearchParams : de
  , Vt = typeof FormData < "u" ? FormData : null
  , Wt = typeof Blob < "u" ? Blob : null
  , Kt = {
	isBrowser: !0,
	classes: {
		URLSearchParams: Jt,
		FormData: Vt,
		Blob: Wt
	},
	protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , Je = typeof window < "u" && typeof document < "u"
  , Gt = (e=>Je && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product)
  , Xt = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , Qt = Object.freeze(Object.defineProperty({
	__proto__: null,
	hasBrowserEnv: Je,
	hasStandardBrowserEnv: Gt,
	hasStandardBrowserWebWorkerEnv: Xt
}, Symbol.toStringTag, {
	value: "Module"
}))
  , N = {
	...Qt,
	...Kt
};
function Zt(e, t) {
	return X(e, new N.classes.URLSearchParams, Object.assign({
		visitor: function(n, r, o, i) {
			return N.isNode && a.isBuffer(n) ? (this.append(r, n.toString("base64")),
			!1) : i.defaultVisitor.apply(this, arguments)
		}
	}, t))
}
function Yt(e) {
	return a.matchAll(/\w+|\[(\w*)]/g, e).map(t=>t[0] === "[]" ? "" : t[1] || t[0])
}
function en(e) {
	const t = {}
	  , n = Object.keys(e);
	let r;
	const o = n.length;
	let i;
	for (r = 0; r < o; r++)
		i = n[r],
		t[i] = e[i];
	return t
}
function Ve(e) {
	function t(n, r, o, i) {
		let s = n[i++];
		if (s === "__proto__")
			return !0;
		const c = Number.isFinite(+s)
		  , u = i >= n.length;
		return s = !s && a.isArray(o) ? o.length : s,
		u ? (a.hasOwnProp(o, s) ? o[s] = [o[s], r] : o[s] = r,
		!c) : ((!o[s] || !a.isObject(o[s])) && (o[s] = []),
		t(n, r, o[s], i) && a.isArray(o[s]) && (o[s] = en(o[s])),
		!c)
	}
	if (a.isFormData(e) && a.isFunction(e.entries)) {
		const n = {};
		return a.forEachEntry(e, (r,o)=>{
			t(Yt(r), o, n, 0)
		}
		),
		n
	}
	return null
}
function tn(e, t, n) {
	if (a.isString(e))
		try {
			return (t || JSON.parse)(e),
			a.trim(e)
		} catch (r) {
			if (r.name !== "SyntaxError")
				throw r
		}
	return (n || JSON.stringify)(e)
}
const pe = {
	transitional: Me,
	adapter: ["xhr", "http"],
	transformRequest: [function(t, n) {
		const r = n.getContentType() || ""
		  , o = r.indexOf("application/json") > -1
		  , i = a.isObject(t);
		if (i && a.isHTMLForm(t) && (t = new FormData(t)),
		a.isFormData(t))
			return o && o ? JSON.stringify(Ve(t)) : t;
		if (a.isArrayBuffer(t) || a.isBuffer(t) || a.isStream(t) || a.isFile(t) || a.isBlob(t))
			return t;
		if (a.isArrayBufferView(t))
			return t.buffer;
		if (a.isURLSearchParams(t))
			return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
			t.toString();
		let c;
		if (i) {
			if (r.indexOf("application/x-www-form-urlencoded") > -1)
				return Zt(t, this.formSerializer).toString();
			if ((c = a.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
				const u = this.env && this.env.FormData;
				return X(c ? {
					"files[]": t
				} : t, u && new u, this.formSerializer)
			}
		}
		return i || o ? (n.setContentType("application/json", !1),
		tn(t)) : t
	}
	],
	transformResponse: [function(t) {
		const n = this.transitional || pe.transitional
		  , r = n && n.forcedJSONParsing
		  , o = this.responseType === "json";
		if (t && a.isString(t) && (r && !this.responseType || o)) {
			const s = !(n && n.silentJSONParsing) && o;
			try {
				return JSON.parse(t)
			} catch (c) {
				if (s)
					throw c.name === "SyntaxError" ? m.from(c, m.ERR_BAD_RESPONSE, this, null, this.response) : c
			}
		}
		return t
	}
	],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: {
		FormData: N.classes.FormData,
		Blob: N.classes.Blob
	},
	validateStatus: function(t) {
		return t >= 200 && t < 300
	},
	headers: {
		common: {
			Accept: "application/json, text/plain, */*",
			"Content-Type": void 0
		}
	}
};
a.forEach(["delete", "get", "head", "post", "put", "patch"], e=>{
	pe.headers[e] = {}
}
);
const he = pe
  , nn = a.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , rn = e=>{
	const t = {};
	let n, r, o;
	return e && e.split(`
`).forEach(function(s) {
		o = s.indexOf(":"),
		n = s.substring(0, o).trim().toLowerCase(),
		r = s.substring(o + 1).trim(),
		!(!n || t[n] && nn[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
	}),
	t
}
  , Ae = Symbol("internals");
function I(e) {
	return e && String(e).trim().toLowerCase()
}
function M(e) {
	return e === !1 || e == null ? e : a.isArray(e) ? e.map(M) : String(e)
}
function on(e) {
	const t = Object.create(null)
	  , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	let r;
	for (; r = n.exec(e); )
		t[r[1]] = r[2];
	return t
}
const sn = e=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function te(e, t, n, r, o) {
	if (a.isFunction(r))
		return r.call(this, t, n);
	if (o && (t = n),
	!!a.isString(t)) {
		if (a.isString(r))
			return t.indexOf(r) !== -1;
		if (a.isRegExp(r))
			return r.test(t)
	}
}
function an(e) {
	return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t,n,r)=>n.toUpperCase() + r)
}
function cn(e, t) {
	const n = a.toCamelCase(" " + t);
	["get", "set", "has"].forEach(r=>{
		Object.defineProperty(e, r + n, {
			value: function(o, i, s) {
				return this[r].call(this, t, o, i, s)
			},
			configurable: !0
		})
	}
	)
}
class Q {
	constructor(t) {
		t && this.set(t)
	}
	set(t, n, r) {
		const o = this;
		function i(c, u, d) {
			const f = I(u);
			if (!f)
				throw new Error("header name must be a non-empty string");
			const l = a.findKey(o, f);
			(!l || o[l] === void 0 || d === !0 || d === void 0 && o[l] !== !1) && (o[l || u] = M(c))
		}
		const s = (c,u)=>a.forEach(c, (d,f)=>i(d, f, u));
		return a.isPlainObject(t) || t instanceof this.constructor ? s(t, n) : a.isString(t) && (t = t.trim()) && !sn(t) ? s(rn(t), n) : t != null && i(n, t, r),
		this
	}
	get(t, n) {
		if (t = I(t),
		t) {
			const r = a.findKey(this, t);
			if (r) {
				const o = this[r];
				if (!n)
					return o;
				if (n === !0)
					return on(o);
				if (a.isFunction(n))
					return n.call(this, o, r);
				if (a.isRegExp(n))
					return n.exec(o);
				throw new TypeError("parser must be boolean|regexp|function")
			}
		}
	}
	has(t, n) {
		if (t = I(t),
		t) {
			const r = a.findKey(this, t);
			return !!(r && this[r] !== void 0 && (!n || te(this, this[r], r, n)))
		}
		return !1
	}
	delete(t, n) {
		const r = this;
		let o = !1;
		function i(s) {
			if (s = I(s),
			s) {
				const c = a.findKey(r, s);
				c && (!n || te(r, r[c], c, n)) && (delete r[c],
				o = !0)
			}
		}
		return a.isArray(t) ? t.forEach(i) : i(t),
		o
	}
	clear(t) {
		const n = Object.keys(this);
		let r = n.length
		  , o = !1;
		for (; r--; ) {
			const i = n[r];
			(!t || te(this, this[i], i, t, !0)) && (delete this[i],
			o = !0)
		}
		return o
	}
	normalize(t) {
		const n = this
		  , r = {};
		return a.forEach(this, (o,i)=>{
			const s = a.findKey(r, i);
			if (s) {
				n[s] = M(o),
				delete n[i];
				return
			}
			const c = t ? an(i) : String(i).trim();
			c !== i && delete n[i],
			n[c] = M(o),
			r[c] = !0
		}
		),
		this
	}
	concat(...t) {
		return this.constructor.concat(this, ...t)
	}
	toJSON(t) {
		const n = Object.create(null);
		return a.forEach(this, (r,o)=>{
			r != null && r !== !1 && (n[o] = t && a.isArray(r) ? r.join(", ") : r)
		}
		),
		n
	}
	[Symbol.iterator]() {
		return Object.entries(this.toJSON())[Symbol.iterator]()
	}
	toString() {
		return Object.entries(this.toJSON()).map(([t,n])=>t + ": " + n).join(`
`)
	}
	get[Symbol.toStringTag]() {
		return "AxiosHeaders"
	}
	static from(t) {
		return t instanceof this ? t : new this(t)
	}
	static concat(t, ...n) {
		const r = new this(t);
		return n.forEach(o=>r.set(o)),
		r
	}
	static accessor(t) {
		const r = (this[Ae] = this[Ae] = {
			accessors: {}
		}).accessors
		  , o = this.prototype;
		function i(s) {
			const c = I(s);
			r[c] || (cn(o, s),
			r[c] = !0)
		}
		return a.isArray(t) ? t.forEach(i) : i(t),
		this
	}
}
Q.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
a.reduceDescriptors(Q.prototype, ({value: e},t)=>{
	let n = t[0].toUpperCase() + t.slice(1);
	return {
		get: ()=>e,
		set(r) {
			this[n] = r
		}
	}
}
);
a.freezeMethods(Q);
const _ = Q;
function ne(e, t) {
	const n = this || he
	  , r = t || n
	  , o = _.from(r.headers);
	let i = r.data;
	return a.forEach(e, function(c) {
		i = c.call(n, i, o.normalize(), t ? t.status : void 0)
	}),
	o.normalize(),
	i
}
function We(e) {
	return !!(e && e.__CANCEL__)
}
function H(e, t, n) {
	m.call(this, e ?? "canceled", m.ERR_CANCELED, t, n),
	this.name = "CanceledError"
}
a.inherits(H, m, {
	__CANCEL__: !0
});
function ln(e, t, n) {
	const r = n.config.validateStatus;
	!n.status || !r || r(n.status) ? e(n) : t(new m("Request failed with status code " + n.status,[m.ERR_BAD_REQUEST, m.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n))
}
const un = N.hasStandardBrowserEnv ? {
	write(e, t, n, r, o, i) {
		const s = [e + "=" + encodeURIComponent(t)];
		a.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()),
		a.isString(r) && s.push("path=" + r),
		a.isString(o) && s.push("domain=" + o),
		i === !0 && s.push("secure"),
		document.cookie = s.join("; ")
	},
	read(e) {
		const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
		return t ? decodeURIComponent(t[3]) : null
	},
	remove(e) {
		this.write(e, "", Date.now() - 864e5)
	}
} : {
	write() {},
	read() {
		return null
	},
	remove() {}
};
function fn(e) {
	return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function dn(e, t) {
	return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
}
function Ke(e, t) {
	return e && !fn(t) ? dn(e, t) : t
}
const pn = N.hasStandardBrowserEnv ? function() {
	const t = /(msie|trident)/i.test(navigator.userAgent)
	  , n = document.createElement("a");
	let r;
	function o(i) {
		let s = i;
		return t && (n.setAttribute("href", s),
		s = n.href),
		n.setAttribute("href", s),
		{
			href: n.href,
			protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
			host: n.host,
			search: n.search ? n.search.replace(/^\?/, "") : "",
			hash: n.hash ? n.hash.replace(/^#/, "") : "",
			hostname: n.hostname,
			port: n.port,
			pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
		}
	}
	return r = o(window.location.href),
	function(s) {
		const c = a.isString(s) ? o(s) : s;
		return c.protocol === r.protocol && c.host === r.host
	}
}() : function() {
	return function() {
		return !0
	}
}();
function hn(e) {
	const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
	return t && t[1] || ""
}
function mn(e, t) {
	e = e || 10;
	const n = new Array(e)
	  , r = new Array(e);
	let o = 0, i = 0, s;
	return t = t !== void 0 ? t : 1e3,
	function(u) {
		const d = Date.now()
		  , f = r[i];
		s || (s = d),
		n[o] = u,
		r[o] = d;
		let l = i
		  , y = 0;
		for (; l !== o; )
			y += n[l++],
			l = l % e;
		if (o = (o + 1) % e,
		o === i && (i = (i + 1) % e),
		d - s < t)
			return;
		const g = f && d - f;
		return g ? Math.round(y * 1e3 / g) : void 0
	}
}
function Oe(e, t) {
	let n = 0;
	const r = mn(50, 250);
	return o=>{
		const i = o.loaded
		  , s = o.lengthComputable ? o.total : void 0
		  , c = i - n
		  , u = r(c)
		  , d = i <= s;
		n = i;
		const f = {
			loaded: i,
			total: s,
			progress: s ? i / s : void 0,
			bytes: c,
			rate: u || void 0,
			estimated: u && s && d ? (s - i) / u : void 0,
			event: o
		};
		f[t ? "download" : "upload"] = !0,
		e(f)
	}
}
const yn = typeof XMLHttpRequest < "u"
  , wn = yn && function(e) {
	return new Promise(function(n, r) {
		let o = e.data;
		const i = _.from(e.headers).normalize();
		let {responseType: s, withXSRFToken: c} = e, u;
		function d() {
			e.cancelToken && e.cancelToken.unsubscribe(u),
			e.signal && e.signal.removeEventListener("abort", u)
		}
		let f;
		if (a.isFormData(o)) {
			if (N.hasStandardBrowserEnv || N.hasStandardBrowserWebWorkerEnv)
				i.setContentType(!1);
			else if ((f = i.getContentType()) !== !1) {
				const [h,...E] = f ? f.split(";").map(R=>R.trim()).filter(Boolean) : [];
				i.setContentType([h || "multipart/form-data", ...E].join("; "))
			}
		}
		let l = new XMLHttpRequest;
		if (e.auth) {
			const h = e.auth.username || ""
			  , E = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
			i.set("Authorization", "Basic " + btoa(h + ":" + E))
		}
		const y = Ke(e.baseURL, e.url);
		l.open(e.method.toUpperCase(), ze(y, e.params, e.paramsSerializer), !0),
		l.timeout = e.timeout;
		function g() {
			if (!l)
				return;
			const h = _.from("getAllResponseHeaders"in l && l.getAllResponseHeaders())
			  , R = {
				data: !s || s === "text" || s === "json" ? l.responseText : l.response,
				status: l.status,
				statusText: l.statusText,
				headers: h,
				config: e,
				request: l
			};
			ln(function(F) {
				n(F),
				d()
			}, function(F) {
				r(F),
				d()
			}, R),
			l = null
		}
		if ("onloadend"in l ? l.onloadend = g : l.onreadystatechange = function() {
			!l || l.readyState !== 4 || l.status === 0 && !(l.responseURL && l.responseURL.indexOf("file:") === 0) || setTimeout(g)
		}
		,
		l.onabort = function() {
			l && (r(new m("Request aborted",m.ECONNABORTED,e,l)),
			l = null)
		}
		,
		l.onerror = function() {
			r(new m("Network Error",m.ERR_NETWORK,e,l)),
			l = null
		}
		,
		l.ontimeout = function() {
			let E = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
			const R = e.transitional || Me;
			e.timeoutErrorMessage && (E = e.timeoutErrorMessage),
			r(new m(E,R.clarifyTimeoutError ? m.ETIMEDOUT : m.ECONNABORTED,e,l)),
			l = null
		}
		,
		N.hasStandardBrowserEnv && (c && a.isFunction(c) && (c = c(e)),
		c || c !== !1 && pn(y))) {
			const h = e.xsrfHeaderName && e.xsrfCookieName && un.read(e.xsrfCookieName);
			h && i.set(e.xsrfHeaderName, h)
		}
		o === void 0 && i.setContentType(null),
		"setRequestHeader"in l && a.forEach(i.toJSON(), function(E, R) {
			l.setRequestHeader(R, E)
		}),
		a.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials),
		s && s !== "json" && (l.responseType = e.responseType),
		typeof e.onDownloadProgress == "function" && l.addEventListener("progress", Oe(e.onDownloadProgress, !0)),
		typeof e.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", Oe(e.onUploadProgress)),
		(e.cancelToken || e.signal) && (u = h=>{
			l && (r(!h || h.type ? new H(null,e,l) : h),
			l.abort(),
			l = null)
		}
		,
		e.cancelToken && e.cancelToken.subscribe(u),
		e.signal && (e.signal.aborted ? u() : e.signal.addEventListener("abort", u)));
		const p = hn(y);
		if (p && N.protocols.indexOf(p) === -1) {
			r(new m("Unsupported protocol " + p + ":",m.ERR_BAD_REQUEST,e));
			return
		}
		l.send(o || null)
	}
	)
}
  , ae = {
	http: Ht,
	xhr: wn
};
a.forEach(ae, (e,t)=>{
	if (e) {
		try {
			Object.defineProperty(e, "name", {
				value: t
			})
		} catch {}
		Object.defineProperty(e, "adapterName", {
			value: t
		})
	}
}
);
const Te = e=>`- ${e}`
  , gn = e=>a.isFunction(e) || e === null || e === !1
  , Ge = {
	getAdapter: e=>{
		e = a.isArray(e) ? e : [e];
		const {length: t} = e;
		let n, r;
		const o = {};
		for (let i = 0; i < t; i++) {
			n = e[i];
			let s;
			if (r = n,
			!gn(n) && (r = ae[(s = String(n)).toLowerCase()],
			r === void 0))
				throw new m(`Unknown adapter '${s}'`);
			if (r)
				break;
			o[s || "#" + i] = r
		}
		if (!r) {
			const i = Object.entries(o).map(([c,u])=>`adapter ${c} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build"));
			let s = t ? i.length > 1 ? `since :
` + i.map(Te).join(`
`) : " " + Te(i[0]) : "as no adapter specified";
			throw new m("There is no suitable adapter to dispatch the request " + s,"ERR_NOT_SUPPORT")
		}
		return r
	}
	,
	adapters: ae
};
function re(e) {
	if (e.cancelToken && e.cancelToken.throwIfRequested(),
	e.signal && e.signal.aborted)
		throw new H(null,e)
}
function Pe(e) {
	return re(e),
	e.headers = _.from(e.headers),
	e.data = ne.call(e, e.transformRequest),
	["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1),
	Ge.getAdapter(e.adapter || he.adapter)(e).then(function(r) {
		return re(e),
		r.data = ne.call(e, e.transformResponse, r),
		r.headers = _.from(r.headers),
		r
	}, function(r) {
		return We(r) || (re(e),
		r && r.response && (r.response.data = ne.call(e, e.transformResponse, r.response),
		r.response.headers = _.from(r.response.headers))),
		Promise.reject(r)
	})
}
const xe = e=>e instanceof _ ? e.toJSON() : e;
function B(e, t) {
	t = t || {};
	const n = {};
	function r(d, f, l) {
		return a.isPlainObject(d) && a.isPlainObject(f) ? a.merge.call({
			caseless: l
		}, d, f) : a.isPlainObject(f) ? a.merge({}, f) : a.isArray(f) ? f.slice() : f
	}
	function o(d, f, l) {
		if (a.isUndefined(f)) {
			if (!a.isUndefined(d))
				return r(void 0, d, l)
		} else
			return r(d, f, l)
	}
	function i(d, f) {
		if (!a.isUndefined(f))
			return r(void 0, f)
	}
	function s(d, f) {
		if (a.isUndefined(f)) {
			if (!a.isUndefined(d))
				return r(void 0, d)
		} else
			return r(void 0, f)
	}
	function c(d, f, l) {
		if (l in t)
			return r(d, f);
		if (l in e)
			return r(void 0, d)
	}
	const u = {
		url: i,
		method: i,
		data: i,
		baseURL: s,
		transformRequest: s,
		transformResponse: s,
		paramsSerializer: s,
		timeout: s,
		timeoutMessage: s,
		withCredentials: s,
		withXSRFToken: s,
		adapter: s,
		responseType: s,
		xsrfCookieName: s,
		xsrfHeaderName: s,
		onUploadProgress: s,
		onDownloadProgress: s,
		decompress: s,
		maxContentLength: s,
		maxBodyLength: s,
		beforeRedirect: s,
		transport: s,
		httpAgent: s,
		httpsAgent: s,
		cancelToken: s,
		socketPath: s,
		responseEncoding: s,
		validateStatus: c,
		headers: (d,f)=>o(xe(d), xe(f), !0)
	};
	return a.forEach(Object.keys(Object.assign({}, e, t)), function(f) {
		const l = u[f] || o
		  , y = l(e[f], t[f], f);
		a.isUndefined(y) && l !== c || (n[f] = y)
	}),
	n
}
const Xe = "1.6.5"
  , me = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e,t)=>{
	me[e] = function(r) {
		return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
	}
}
);
const Ne = {};
me.transitional = function(t, n, r) {
	function o(i, s) {
		return "[Axios v" + Xe + "] Transitional option '" + i + "'" + s + (r ? ". " + r : "")
	}
	return (i,s,c)=>{
		if (t === !1)
			throw new m(o(s, " has been removed" + (n ? " in " + n : "")),m.ERR_DEPRECATED);
		return n && !Ne[s] && (Ne[s] = !0,
		console.warn(o(s, " has been deprecated since v" + n + " and will be removed in the near future"))),
		t ? t(i, s, c) : !0
	}
}
;
function bn(e, t, n) {
	if (typeof e != "object")
		throw new m("options must be an object",m.ERR_BAD_OPTION_VALUE);
	const r = Object.keys(e);
	let o = r.length;
	for (; o-- > 0; ) {
		const i = r[o]
		  , s = t[i];
		if (s) {
			const c = e[i]
			  , u = c === void 0 || s(c, i, e);
			if (u !== !0)
				throw new m("option " + i + " must be " + u,m.ERR_BAD_OPTION_VALUE);
			continue
		}
		if (n !== !0)
			throw new m("Unknown option " + i,m.ERR_BAD_OPTION)
	}
}
const ce = {
	assertOptions: bn,
	validators: me
}
  , L = ce.validators;
class V {
	constructor(t) {
		this.defaults = t,
		this.interceptors = {
			request: new Re,
			response: new Re
		}
	}
	request(t, n) {
		typeof t == "string" ? (n = n || {},
		n.url = t) : n = t || {},
		n = B(this.defaults, n);
		const {transitional: r, paramsSerializer: o, headers: i} = n;
		r !== void 0 && ce.assertOptions(r, {
			silentJSONParsing: L.transitional(L.boolean),
			forcedJSONParsing: L.transitional(L.boolean),
			clarifyTimeoutError: L.transitional(L.boolean)
		}, !1),
		o != null && (a.isFunction(o) ? n.paramsSerializer = {
			serialize: o
		} : ce.assertOptions(o, {
			encode: L.function,
			serialize: L.function
		}, !0)),
		n.method = (n.method || this.defaults.method || "get").toLowerCase();
		let s = i && a.merge(i.common, i[n.method]);
		i && a.forEach(["delete", "get", "head", "post", "put", "patch", "common"], p=>{
			delete i[p]
		}
		),
		n.headers = _.concat(s, i);
		const c = [];
		let u = !0;
		this.interceptors.request.forEach(function(h) {
			typeof h.runWhen == "function" && h.runWhen(n) === !1 || (u = u && h.synchronous,
			c.unshift(h.fulfilled, h.rejected))
		});
		const d = [];
		this.interceptors.response.forEach(function(h) {
			d.push(h.fulfilled, h.rejected)
		});
		let f, l = 0, y;
		if (!u) {
			const p = [Pe.bind(this), void 0];
			for (p.unshift.apply(p, c),
			p.push.apply(p, d),
			y = p.length,
			f = Promise.resolve(n); l < y; )
				f = f.then(p[l++], p[l++]);
			return f
		}
		y = c.length;
		let g = n;
		for (l = 0; l < y; ) {
			const p = c[l++]
			  , h = c[l++];
			try {
				g = p(g)
			} catch (E) {
				h.call(this, E);
				break
			}
		}
		try {
			f = Pe.call(this, g)
		} catch (p) {
			return Promise.reject(p)
		}
		for (l = 0,
		y = d.length; l < y; )
			f = f.then(d[l++], d[l++]);
		return f
	}
	getUri(t) {
		t = B(this.defaults, t);
		const n = Ke(t.baseURL, t.url);
		return ze(n, t.params, t.paramsSerializer)
	}
}
a.forEach(["delete", "get", "head", "options"], function(t) {
	V.prototype[t] = function(n, r) {
		return this.request(B(r || {}, {
			method: t,
			url: n,
			data: (r || {}).data
		}))
	}
});
a.forEach(["post", "put", "patch"], function(t) {
	function n(r) {
		return function(i, s, c) {
			return this.request(B(c || {}, {
				method: t,
				headers: r ? {
					"Content-Type": "multipart/form-data"
				} : {},
				url: i,
				data: s
			}))
		}
	}
	V.prototype[t] = n(),
	V.prototype[t + "Form"] = n(!0)
});
const J = V;
class ye {
	constructor(t) {
		if (typeof t != "function")
			throw new TypeError("executor must be a function.");
		let n;
		this.promise = new Promise(function(i) {
			n = i
		}
		);
		const r = this;
		this.promise.then(o=>{
			if (!r._listeners)
				return;
			let i = r._listeners.length;
			for (; i-- > 0; )
				r._listeners[i](o);
			r._listeners = null
		}
		),
		this.promise.then = o=>{
			let i;
			const s = new Promise(c=>{
				r.subscribe(c),
				i = c
			}
			).then(o);
			return s.cancel = function() {
				r.unsubscribe(i)
			}
			,
			s
		}
		,
		t(function(i, s, c) {
			r.reason || (r.reason = new H(i,s,c),
			n(r.reason))
		})
	}
	throwIfRequested() {
		if (this.reason)
			throw this.reason
	}
	subscribe(t) {
		if (this.reason) {
			t(this.reason);
			return
		}
		this._listeners ? this._listeners.push(t) : this._listeners = [t]
	}
	unsubscribe(t) {
		if (!this._listeners)
			return;
		const n = this._listeners.indexOf(t);
		n !== -1 && this._listeners.splice(n, 1)
	}
	static source() {
		let t;
		return {
			token: new ye(function(o) {
				t = o
			}
			),
			cancel: t
		}
	}
}
const En = ye;
function Sn(e) {
	return function(n) {
		return e.apply(null, n)
	}
}
function Rn(e) {
	return a.isObject(e) && e.isAxiosError === !0
}
const le = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	ImUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	Unused: 306,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	UriTooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HttpVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511
};
Object.entries(le).forEach(([e,t])=>{
	le[t] = e
}
);
const An = le;
function Qe(e) {
	const t = new J(e)
	  , n = _e(J.prototype.request, t);
	return a.extend(n, J.prototype, t, {
		allOwnKeys: !0
	}),
	a.extend(n, t, null, {
		allOwnKeys: !0
	}),
	n.create = function(o) {
		return Qe(B(e, o))
	}
	,
	n
}
const w = Qe(he);
w.Axios = J;
w.CanceledError = H;
w.CancelToken = En;
w.isCancel = We;
w.VERSION = Xe;
w.toFormData = X;
w.AxiosError = m;
w.Cancel = w.CanceledError;
w.all = function(t) {
	return Promise.all(t)
}
;
w.spread = Sn;
w.isAxiosError = Rn;
w.mergeConfig = B;
w.AxiosHeaders = _;
w.formToJSON = e=>Ve(a.isHTMLForm(e) ? new FormData(e) : e);
w.getAdapter = Ge.getAdapter;
w.HttpStatusCode = An;
w.default = w;
const On = w;
/*! js-cookie v3.0.5 | MIT */
function v(e) {
	for (var t = 1; t < arguments.length; t++) {
		var n = arguments[t];
		for (var r in n)
			e[r] = n[r]
	}
	return e
}
var Tn = {
	read: function(e) {
		return e[0] === '"' && (e = e.slice(1, -1)),
		e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
	},
	write: function(e) {
		return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
	}
};
function ue(e, t) {
	function n(o, i, s) {
		if (!(typeof document > "u")) {
			s = v({}, t, s),
			typeof s.expires == "number" && (s.expires = new Date(Date.now() + s.expires * 864e5)),
			s.expires && (s.expires = s.expires.toUTCString()),
			o = encodeURIComponent(o).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
			var c = "";
			for (var u in s)
				s[u] && (c += "; " + u,
				s[u] !== !0 && (c += "=" + s[u].split(";")[0]));
			return document.cookie = o + "=" + e.write(i, o) + c
		}
	}
	function r(o) {
		if (!(typeof document > "u" || arguments.length && !o)) {
			for (var i = document.cookie ? document.cookie.split("; ") : [], s = {}, c = 0; c < i.length; c++) {
				var u = i[c].split("=")
				  , d = u.slice(1).join("=");
				try {
					var f = decodeURIComponent(u[0]);
					if (s[f] = e.read(d, f),
					o === f)
						break
				} catch {}
			}
			return o ? s[o] : s
		}
	}
	return Object.create({
		set: n,
		get: r,
		remove: function(o, i) {
			n(o, "", v({}, i, {
				expires: -1
			}))
		},
		withAttributes: function(o) {
			return ue(this.converter, v({}, this.attributes, o))
		},
		withConverter: function(o) {
			return ue(v({}, this.converter, o), this.attributes)
		}
	}, {
		attributes: {
			value: Object.freeze(t)
		},
		converter: {
			value: Object.freeze(e)
		}
	})
}
var Z = ue(Tn, {
	path: "/"
});
new Date().getFullYear();
const Hn = "AIAuth"
  , Ze = "AIID"
  , Ye = "AICookieAccepted"
  , vn = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
class Pn {
	static token = void 0
}
const xn = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Nn = (e=21)=>{
	let t = ""
	  , n = crypto.getRandomValues(new Uint8Array(e));
	for (; e--; )
		t += xn[n[e] & 63];
	return t
}
;
const Ce = "uniqUserId"
  , et = ()=>{
	let e = localStorage.getItem(Ce);
	return e || (e = Nn(),
	localStorage.setItem(Ce, e)),
	e
}
  , A = ()=>et();
function Cn() {
	return window.location.hostname.replace("lp1.", "").replace("lp2.", "")
}
const b = On.create({
	baseURL: !window.location.host.includes("npstage") && !window.location.host.includes("localhost") && !window.location.host.includes("192.168") ? "https://api.ifriend.ai" : "https://api.ifriend..nptest.org/",
	timeout: 1e4
})
  , O = async()=>it(()=>import("./markers.knhZWxmI.js"), __vite__mapDeps([0, 1])).then(async({MarkersService: e})=>{
	let t = {};
	try {
		t = await e.getMarkers()
	} catch {}
	return {
		link: document.location.origin + document.location.pathname,
		link_full: e.getFullPathWithMarkers(),
		AFID: t.afid,
		StageName: t.utm_source,
		Campaign: t.utm_campaign
	}
}
)
  , x = e=>Promise.reject(e.response || {
	code: 500
})
  , Y = async({data: e, headers: t})=>{
	const {id: n, email: r} = e;
	n && (P = n,
	Z.set(Ze, n, {
		expires: 365,
		domain: Cn()
	}));
	const o = t["x-token"] || "";
	return o && (Pn.token = o),
	b.interceptors.request.use(i=>(o ? i.headers.authorization = `Token token="${o}"` : delete b.defaults.headers.common.authorization,
	i), i=>Promise.reject(i)),
	{
		id: P,
		email: r
	}
}
;
let P = Z.get(Ze) ?? "";
async function zn(e, t) {
	return await b.get("/identity", {
		headers: {
			authorization: `Basic ${btoa(`${e}:${t}`)}`
		}
	}).then(Y).catch(x)
}
async function Mn(e, t) {
	return await b.put("/identity", {
		email: e,
		password: t
	}).then(Y).catch(x)
}
async function Jn(e) {
	return await b.get("/identity", {
		headers: {
			Authorization: `Google token="${e}"`
		}
	}).then(Y)
}
async function Vn(e, t) {
	return await b.put("/identity", {
		email: `google://${e}`
	}).then(Y).then(()=>Promise.all([_n(), Un({
		name: t.name,
		gender: t.gender
	}), Ln(), Fn()])).catch(x)
}
async function kn() {
	return await b.get("/location").catch(x)
}
async function _n(e) {
	const t = e?.replace("-", "");
	return Promise.all([b.post(`users/${P}/tags/ai.product/edenai`), t && b.post(`users/${P}/tags/ai.registration.landing/${t}`)]).catch(x)
}
async function Un(e) {
	return await b.patch(`users/${P}`, {
		...e,
		birthday: `${new Date().getFullYear() - 21}-12-31T00:00:00Z`
	}).catch(x)
}
async function Fn() {
	return await b.patch(`ai/users/${P}/preferences`, {
		personality: "flirty",
		birthday: "1999-12-31T23:00:00Z",
		name: "Jessica",
		gender: "fem",
		ethnicity: "caucasian"
	}).catch(x)
}
async function Ln() {
	return await b.patch(`ai/users/${P}/onboarding-answers`, {
		selectedBot: "anna"
	}).catch(x)
}
async function Wn(e) {
	return await b.post("reminders/password", {
		type: "password",
		email: e
	}).catch(x)
}
async function Kn(e, t) {
	return await b.patch("identity", {
		password: e
	}, {
		headers: {
			authorization: `Token token="${t}"`
		}
	}).catch(x)
}
async function Gn() {
	const [{data: e},{data: t}] = await Promise.all([b.get(`users/${P}/tags`), b.get(`users/${P}/tags/experiments`)]);
	return e.concat(t)
}
async function Xn(e) {
	return await b.put(`/analytics/${P}/registration`, e).catch(x)
}
async function j(e, t) {
	await S("onboarding-steps-ai", {
		"step-name": e,
		value: t
	})
}
async function Qn({name: e, age: t, gender: n}) {
	await Promise.all([j("user-name", e), j("user-age", t), j("user-gender", n), j("bot-gender", "fem"), j("ai-personality", "flirty")])
}
async function Zn() {
	await S("onboarding-finished-ai")
}
async function Yn() {
	let e = A();
	const t = await O();
	await S("before-auth-page-view-web-ai", {
		id: e,
		payload: t
	})
}
function tt(e) {
	return async t=>{
		const n = A()
		  , r = await O();
		await Promise.all([S("auth-finished", {
			auth_type: e,
			method: t
		}), S("auth-finished-web-ai", {
			id: n,
			type: t,
			auth_type: e,
			payload: r
		})])
	}
}
const er = tt("signin")
  , tr = tt("signup")
  , ke = e=>{
	if (!e)
		return;
	let t = "";
	switch (e) {
	case "name":
	case "email":
		t = `your_${e}`;
		break;
	case "male":
	case "female":
		t = "identity";
		break;
	default:
		t = e
	}
	return t
}
  , Bn = (e="")=>e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  , Dn = (e,t,n)=>e.replace(new RegExp(Bn(t),"g"), ()=>n)
  , k = ()=>document.location?.pathname?.replaceAll && typeof document.location.pathname.replaceAll == "function" ? document.location.pathname.replaceAll("/", "") : Dn(document.location.pathname, "/", "")
  , nr = {
	clickRegistrationInput: async e=>{
		if (!e)
			return;
		const t = ke(e)
		  , n = k();
		if (!t || !n)
			return;
		const r = await O();
		S("click-registration-input-field-before-auth-page-web-ai", {
			id: A(),
			input_field: t,
			landing: n === "signup" ? "main" : n,
			payload: r
		})
	}
	,
	enterRegistrationInput: async e=>{
		if (localStorage.getItem("ANAL_SENT_REGISTRATION_ENTER"))
			return;
		const n = ke(e)
		  , r = k();
		if (!n || !r)
			return;
		const o = await O();
		S("fill-registration-input-field-before-auth-page-web-ai", {
			id: A(),
			input_field: n,
			landing: r === "signup" ? "main" : r,
			payload: o
		}),
		localStorage.setItem("ANAL_SENT_REGISTRATION_ENTER", "true")
	}
	,
	enterRegistrationName: async()=>{
		const e = k();
		if (!e)
			return;
		const t = await O();
		S("fill-registration-input-field-your-name-before-auth-page-web-ai", {
			id: A(),
			landing: e === "signup" ? "main" : e,
			payload: t
		})
	}
	,
	enterRegistrationEmail: async()=>{
		const e = k();
		if (!e)
			return;
		const t = await O();
		S("fill-registration-input-field-your-email-before-auth-page-web-ai", {
			id: A(),
			landing: e === "signup" ? "main" : e,
			payload: t
		})
	}
	,
	enterRegistrationSex: async()=>{
		const e = k();
		if (!e)
			return;
		const t = await O();
		S("fill-registration-input-field-identity-before-auth-page-web-ai", {
			id: A(),
			landing: e === "signup" ? "main" : e,
			payload: t
		})
	}
	,
	enterRegistrationPassword: async()=>{
		const e = k();
		if (!e)
			return;
		const t = await O();
		S("fill-registration-input-field-password-before-auth-page-web-ai", {
			id: A(),
			landing: e === "signup" ? "main" : e,
			payload: t
		})
	}
	,
	clickRegistrationContinueButton: async()=>{
		const e = k();
		if (!e)
			return;
		const t = await O();
		S("click-continue-btn-before-auth-page-web-ai", {
			id: A(),
			landing: e === "signup" ? "main" : e,
			payload: t
		})
	}
	,
	clickRegistrationContinueButtonWithError: async(e,t)=>{
		const n = k();
		if (!n)
			return;
		const r = {
			error: "",
			name: "",
			email: "",
			identity: "",
			password: !1
		}
		  , o = {
			...t
		}
		  , i = e?.reduce((c,{field: u, message: d, fieldValue: f})=>(delete o[u],
		u === "gender" ? c.identity = f : c[u] = f,
		c.error = c.error ? c.error + `, ${d}` : d,
		c), r)
		  , s = await O();
		return S("error-on-click-continue-btn-before-auth-page-web-ai", {
			id: A(),
			landing: n === "signup" ? "main" : n,
			...i,
			...o,
			password: !!i.password || !!o.password,
			identity: o.gender,
			payload: s
		})
	}
	,
	clickSignInGoogle: async()=>{
		const e = await O();
		S("click-sign-in-with-google-btn-before-auth-page-web-ai", {
			id: A(),
			landing: "main",
			payload: e
		})
	}
	,
	errorGoogleSignIn: async e=>{
		const t = await O();
		return S("error-sign-in-with-google-before-auth-page-web-ai", {
			id: A(),
			error: e,
			landing: "main",
			payload: t
		})
	}
	,
	clickContinueWithEmail: async()=>{
		const e = k()
		  , t = await O();
		return ()=>{
			S("click-continue-with-email-btn-before-auth-page-web-ai", {
				id: A(),
				landing: e === "signup" || !e ? "main" : e,
				payload: t
			})
		}
	}
};
async function S(e, t) {
	const n = P || "nouser"
	  , r = Date.now() / 1e3 | 0;
	try {
		await b.post(`/annals/${n}/${e}`, {
			timestamp: r,
			...t
		})
	} catch {}
}
class In {
	location = "";
	getLocation = async()=>{
		if (this.location)
			return this.location;
		try {
			const {data: t} = await kn();
			this.location = t.country
		} catch {
			this.location = "N/A"
		}
		return this.location
	}
}
const rr = new In
  , nt = "query_params"
  , jn = ()=>{
	const [e,t] = location.href.split("?");
	if (t)
		try {
			localStorage.setItem(nt, t)
		} catch {}
}
  , or = ()=>{
	try {
		localStorage.removeItem(nt)
	} catch {}
}
;
jn();
et();
function qn() {
	function e() {
		const n = window.innerHeight * .01;
		document.documentElement.style.setProperty("--vh", n + "px")
	}
	e();
	let t;
	window.addEventListener("resize", ()=>{
		clearTimeout(t),
		t = setTimeout(e, 100)
	}
	)
}
qn();
const $n = Z.get(Ye) || !1
  , oe = document.querySelector(".cookie");
if (oe) {
	const e = document.querySelector("#cookie-close");
	e && e.addEventListener("click", ()=>{
		oe.classList.add("cookie--hidden"),
		Z.set(Ye, "true")
	}
	),
	$n || oe.classList.remove("cookie--hidden")
}
export {Pn as A, rr as L, nt as Q, Yn as a, nr as b, Fn as c, er as d, vn as e, Vn as f, Jn as g, Wn as h, Kn as i, zn as j, tr as k, Qn as l, Gn as m, Zn as n, Ln as o, Xn as p, Z as q, Mn as r, Ze as s, _n as t, Un as u, Cn as v, Hn as w, or as x};

const e = document.querySelector("[data-back-form]")
  , o = ()=>{
	e && e.addEventListener("click", ()=>{
		e.closest(".main__form")?.classList.remove("signup")
	}
	)
}
;
o();
import {q as e} from "./base.Dp3-MWEb.js";
import {L as r} from "./Cookie.astro_astro_type_script_index_0_lang.WHDXDktG.js";
class t {
	locationService;
	allowedMarkers = ["afid", "fb-psid", "subafid", "afid2", "subid2", "referrer", "gclid", "offer-id", "goal-id", "clickid", "transaction-id", "transaction_id", "country", "tracker", "utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content", "smart-landing"];
	hash = e.parse(window.location.hash);
	search = e.parse(window.location.search);
	session = JSON.parse(sessionStorage.getItem("markers") || "{}");
	responseMarkers = {};
	pathWithMarkers = "";
	constructor(s) {
		this.locationService = s,
		this.pathWithMarkers = document.location.href,
		this.init()
	}
	init = ()=>{
		if (Object.keys(this.session).length > 0) {
			this.responseMarkers = this.session,
			console.log(this.session);
			return
		}
		return this.allowedMarkers.forEach(s=>{
			if (this.hash[s]) {
				this.responseMarkers[s] = this.hash[s];
				return
			}
			if (this.search[s]) {
				this.responseMarkers[s] = this.search[s],
				Array.isArray(this.search[s]) && (this.responseMarkers[s] = this.search[s]?.[0]);
				return
			}
			document[s] && !this.responseMarkers[s] && (this.responseMarkers[s] = document[s])
		}
		),
		sessionStorage.setItem("markers", JSON.stringify(this.responseMarkers))
	}
	;
	getMarkers = async()=>(this.init(),
	{
		...this.responseMarkers,
		country: await this.locationService.getLocation(),
		referrer: this.responseMarkers.referrer || document.referrer || window.location.href,
		emguid: 0,
		tracker: null
	});
	getFullPathWithMarkers = ()=>this.pathWithMarkers
}
const n = new t(r);
export {n as MarkersService};

import {L as p, q as s, s as o, v as l, w as m, Q as y, x as u, A as v} from "./Cookie.astro_astro_type_script_index_0_lang.WHDXDktG.js";
function S(a) {
	return new URLSearchParams(a.split("?")[1]).get("afid") ?? ""
}
class w {
	locationService;
	constructor(e) {
		this.locationService = e
	}
	firstInputStarted = !1;
	savedMarkers = JSON.parse(sessionStorage.getItem("markers") || "{}");
	afid = this.savedMarkers?.afid ?? S(window.location.href);
	sendFirstInput = async()=>{
		if (!this.firstInputStarted)
			return window.dataLayer.push({
				country: await this.locationService.getLocation(),
				afid: this.afid,
				form: {
					name: "register",
					id: "form-register",
					action: "start-fill",
					type: "register"
				},
				event: "event_form_action_changeDL"
			})
	}
	;
	sendRegisterSuccess = async e=>{
		window.dataLayer.push({
			step: 1,
			country: await this.locationService.getLocation(),
			afid: this.afid,
			data: {
				email: e
			},
			user_id: s.get(o) ?? null,
			form: {
				name: "register",
				id: "form-register",
				action: "start-fill",
				type: "register"
			},
			event: "event_registered_changeDL"
		})
	}
	;
	sendRegisterError = async(e,t,c)=>{
		window.dataLayer.push({
			step: 1,
			country: await this.locationService.getLocation(),
			afid: this.afid,
			data: {
				email: e
			},
			form: {
				name: "register",
				id: "form-register",
				action: "start-fill",
				type: "register"
			},
			error: {
				field: t,
				name: c
			},
			event: "event_error_registered_changeDL"
		})
	}
	;
	sendOnboardingSuccess = async(e,t)=>{
		window.dataLayer.push({
			step: 2,
			country: await this.locationService.getLocation(),
			afid: this.afid,
			form: {
				name: "update-user",
				id: "form-user",
				type: "representation-form"
			},
			user_id: s.get(o) ?? null,
			data: {
				name: e,
				age: t
			},
			event: "event_form_action_changeDL"
		})
	}
	;
	sendAuthorizedUser = async({id: e, email: t})=>{
		window.dataLayer.push({
			referrer: this.savedMarkers?.referrer ?? document?.referrer ?? "n/a",
			country: await this.locationService.getLocation(),
			afid: this.afid,
			data: {
				email: t
			},
			event: "event_authorized_changeDL",
			userid_value: e
		})
	}
	;
	sendLoginSuccess = ()=>{
		window.dataLayer.push({
			event: "event_login_changeDL",
			user_id: s.get(o) ?? null
		})
	}
}
const L = new w(p);
function A(a="", e=!1) {
	const t = {
		expires: -1,
		domain: l()
	}
	  , c = location.hostname.includes("npstage")
	  , f = location.hostname.includes("localhost")
	  , n = new URLSearchParams
	  , {token: d} = v;
	d && (s.set(m, "true", {
		expires: 365,
		domain: l(),
		httpOnly: !1
	}),
	n.append("token", d)),
	e && n.append("influencer", "true"),
	L.sendLoginSuccess(),
	s.set(o, "", t),
	localStorage.removeItem("googleCredential");
	let r = null;
	try {
		r = localStorage.getItem(y)
	} catch {
		u()
	}
	let i = n.toString().length > 0 ? "?" + n.toString() : "";
	i ? r && (i += `&${r}`) : r && (i = `?${r}`);
	const g = `https://app.${location.hostname}/${a}${i}`
	  , h = `https://app.edenai.world/${a}${i}`;
	u(),
	location.replace(c || f ? g : h)
}
export {L as G, A as r};
